#!/usr/bin/python3
#
# Copyright (C) 2022 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; If not, see <http://www.gnu.org/licenses/>.

import anacondalib

from installer import Installer
from storage import Storage
from review import Review
from testlib import nondestructive, test_main  # pylint: disable=import-error
from storagelib import StorageHelpers  # pylint: disable=import-error
from utils import pretend_live_iso


@nondestructive
class TestStorage(anacondalib.VirtInstallMachineCase, StorageHelpers):
    efi = False

    def set_valid_password(self, password="abcdefgh"):
        s = Storage(self.browser, self.machine)

        s.set_password(password)
        s.set_password_confirm(password)

    def testLocalStandardDisks(self):
        b = self.browser
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)

        i.open()
        i.next()

        # Check the auto-selected disk's details
        s.check_single_disk_destination("vda", "16.1 GB")

        # Pixel test the storage step
        b.assert_pixels(
            "#app",
            "storage-step-basic",
            ignore=["#betanag-icon"],
            wait_animations=False,
        )

        # This attaches a disk to the running VM
        # However, since the storage module initialization is long completed
        # the newly added disk, will not be visible in the UI,
        # until the test clicks on the re-scan button
        dev = self.add_ram_disk(2)
        dev = dev.split("/")[-1]
        s.rescan_disks()

        # Check that the disk selection persists when moving next and back
        s.check_disk_selected("vda", True)
        i.next()
        i.back()
        s.check_disk_selected("vda", True)

        # Try unselecting the single disk and expect and error
        s.select_disk("vda", False)
        s.wait_no_disks()
        # Check the next button is disabled if no disks are selected
        i.check_next_disabled()

        # Check clear selection of disks
        s.select_disk(dev, True)
        s.select_disk("vda", True)
        s.select_none_disks_and_check([dev, "vda"])

    def testModifyStorage(self):
        b = self.browser
        m = self.machine
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)

        self.addCleanup(m.execute, "killall blivet-gui")

        pretend_live_iso(self)

        # For live media the first screen is the installation-method
        i.open(step="installation-method")

        disk="vda"

        # Check the auto-selected disk's details
        s.check_single_disk_destination(disk, "16.1 GB")

        # Pixel test the storage step
        b.assert_pixels(
            "#app",
            "storage-step-basic-live",
            ignore=["#betanag-icon"],
            wait_animations=False,
        )

        s.modify_storage()
        b.click("#modify-storage-modal-cancel-btn")

        s.modify_storage()
        # Run the tool
        b.click("#modify-storage-modal-modify-btn")
        b.wait_visible(f"#modify-storage-modal-modify-btn:not([aria-disabled={True}]")
        b.wait_visible(f"#storage-modified-modal-rescan-btn")
        b.click("#storage-modified-modal-ignore-btn")
        # The disk is still selected
        s.check_single_disk_destination(disk, "16.1 GB")

        #s.modify_storage()
        #b.click("#modify-storage-modal-cancel-btn")

        s.modify_storage()
        b.click("#modify-storage-modal-modify-btn")
        b.wait_visible(f"#modify-storage-modal-modify-btn:not([aria-disabled={True}]")
        b.wait_visible(f"#storage-modified-modal-rescan-btn")
        b.click("#storage-modified-modal-rescan-btn")
        # The disk is still selected
        s.check_single_disk_destination(disk, "16.1 GB")

    # Test moving back and forth between screens.
    # Disk initialization mode is applied to the backend in the test.
    # Partitioning is not applied to the backend in the test.
    def testAutopartitioning(self):
        b = self.browser
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)

        i.open()
        # Language selection

        i.reach(i.steps.INSTALLATION_METHOD)

        # Check the default mode
        s.check_partitioning_selected("erase-all")

        i.next()
        # Disk Encryption

        i.check_next_disabled(False)

        b.assert_pixels(
            "#app",
            "storage-step-encrypt",
            ignore=["#betanag-icon"],
            wait_animations=False,
        )

        s.check_encryption_selected(False)
        encrypt = True
        s.set_encryption_selected(encrypt)

        # Disk Encryption / password screen
        b.assert_pixels(
            "#app",
            "storage-step-password",
            ignore=["#betanag-icon"],
            wait_animations=False,
        )

        # No password set
        s.check_pw_rule("8-chars", "indeterminate")
        s.check_pw_rule("match", "indeterminate")
        i.check_next_disabled()

        # Set pw which is too short
        s.set_password("abcd")
        s.check_pw_strength(None)
        i.check_next_disabled()
        s.check_pw_rule("8-chars", "error")
        s.check_pw_rule("match", "error")

        # Make the pw 8 chars long
        s.set_password("efgh", append=True, value_check=False)
        i.check_next_disabled()
        s.check_password("abcdefgh")
        s.check_pw_rule("8-chars", "success")
        s.check_pw_rule("match", "error")
        s.check_pw_strength("weak")

        # Non-ASCII password
        s.set_password(8 * "š")
        s.check_password(8 * "š")
        s.check_pw_rule("8-chars", "success")
        s.check_pw_rule("match", "error")
        s.check_pw_rule("ascii", "warning")
        s.check_pw_strength("weak")

        # Valid ASCII password
        s.set_password("abcdefgh")
        s.check_password("abcdefgh")

        # Set the password confirm
        s.set_password_confirm("abcdefg")
        s.check_pw_rule("match", "error")
        s.set_password_confirm("abcdefgh")
        s.check_pw_rule("match", "success")
        s.check_pw_rule("8-chars", "success")
        s.check_pw_strength("weak")
        s.check_password("abcdefgh")
        s.check_password_confirm("abcdefgh")
        i.check_next_disabled(disabled=False)

        # Check setting strong password
        s.set_password("Rwce82ybF7dXtCzFumanchu!!!!!!!!")
        s.check_pw_strength("strong")

    # Test moving back after partitioning is applied,
    # the partitioning should be reset.
    def testAutopartitioningReset(self):
        b = self.browser
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)

        i.open()
        # Language selection

        i.reach(i.steps.INSTALLATION_METHOD)

        # Check the default mode
        s.check_partitioning_selected("erase-all")

        # Check that when an unpartitioned disk is selected the "Use free space" scenario is hidden
        s.wait_scenario_visible("use-free-space", False)

        # Check that when a partitioned disk is selected the "Use free space" scenario is visible
        s.add_basic_partitioning()
        s.wait_scenario_visible("use-free-space")

        s.set_partitioning("use-free-space")

        i.next()
        # Disk Encryption / password screen

        encrypt = True
        s.set_encryption_selected(encrypt)
        s.check_encryption_selected(encrypt)

        # Set valid password
        self.set_valid_password()

        # Verify that the password is saved when moving forward and back
        i.next()
        i.back()
        s.check_password("abcdefgh")
        s.check_password_confirm("abcdefgh")

        i.back()
        # Storage Configuration
        # The choice is preserved (stored in the backend).
        # The choice is available only if the partitioning was reset
        # (there is enough free space)
        s.check_partitioning_selected("use-free-space")

        i.next()
        # The value is preserved
        s.check_encryption_selected(encrypt)

    def testPartitioningObject(self):
        # Test which partitioning object ends up being the AppliedPartitioning
        # when we go back and forward the storage steps

        b = self.browser
        i = Installer(b, self.machine)
        s = Storage(b, self.machine)

        self.addCleanup(s.dbus_reset_partitioning)

        # Read partitioning data before we do anything
        created_partitioning = s.dbus_get_created_partitioning()

        # Go to Review step
        i.open()
        i.reach(i.steps.REVIEW)

        # Read partitioning data after we went to Review step
        new_applied_partitioning = s.dbus_get_applied_partitioning()
        new_created_partitioning = s.dbus_get_created_partitioning()

        # A new AUTOMATIC partitioning object should be created each time the user enters the review page
        self.assertEqual(len(created_partitioning) + 1, len(new_created_partitioning))
        # The applied partitioning object should be the last one created
        self.assertEqual(new_applied_partitioning, new_created_partitioning[-1])

        created_partitioning = new_created_partitioning

        # Create a few partitioning objects and ensure that these will not mess up with the user's
        # configuration
        for _ in range(10):
            s.dbus_create_partitioning("AUTOMATIC")

        # Go back to the previous page and re-enter the review screen.
        # This should create again a new partitioning object and apply it
        # no matter how many partitioning objects were created before
        i.back()
        i.next()
        new_applied_partitioning = s.dbus_get_applied_partitioning()
        new_created_partitioning = s.dbus_get_created_partitioning()

        self.assertEqual(len(created_partitioning) + 11, len(new_created_partitioning))
        self.assertEqual(new_applied_partitioning, new_created_partitioning[-1])

        # The applied partitioning should be reset when going back at any step from review page
        i.click_step_on_sidebar(i.steps.INSTALLATION_METHOD)
        new_applied_partitioning = s.dbus_get_applied_partitioning()
        self.assertEqual(new_applied_partitioning, "")


# TODO add next back test keeping the choice
@nondestructive
class TestStorageExtraDisks(anacondalib.VirtInstallMachineCase, StorageHelpers):
    efi = False

    def testLocalDisksSyncNew(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        # This attaches a disk to the running VM
        # However, since the storage module initialization is long completed
        # the newly added disk, will not be visible in the UI,
        # until the test clicks on the re-scan button
        dev = self.add_ram_disk(2)
        dev = dev.split("/")[-1]

        i.open()
        i.next()

        s.wait_no_disks_detected_not_present()

        s.check_single_disk_destination("vda")

        s.rescan_disks()

        s.check_disk_visible("vda")
        s.check_disk_visible(dev)

        s.wait_no_disks_detected_not_present()

        s.check_disk_selected("vda", True)
        s.check_disk_selected(dev, False)

        s.rescan_disks()

        s.check_disk_selected("vda", True)
        s.check_disk_selected(dev, False)

        s.select_disk(dev)

        # Check that disk selection is kept on Next and Back
        i.next()
        i.back()
        for disk in ["vda", dev]:
            s.check_disk_selected(disk)

class TestUtils():
    def table_row(self, row):
        return f"#mount-point-mapping-table-row-{row}";

    def disks_loaded(self, s, disks):
        usable_disks = s.dbus_get_usable_disks()
        for disk in usable_disks:
            disks_dict = dict(disks)
            if disk not in disks_dict:
                return False

        return True

    def select_mountpoint(self, b, i , s, disks):
        b.wait(lambda : self.disks_loaded(s, disks))

        for disk in disks:
            current_selection = s.get_disk_selected(disk[0])
            if current_selection != disk[1]:
                s.select_disk(disk[0], disk[1], len(disks) == 1)

        s.set_partitioning("mount-point-mapping")
        i.next(next_page=i.steps.CUSTOM_MOUNT_POINT)

    def select_row_mountpoint(self, b, row,  mountpoint):
        b.set_input_text(f"{self.table_row(row)} td[data-label='Mount point'] input", mountpoint)

    def select_row_device(self, b, row,  device):
        selector = f"{self.table_row(row)} .pf-v5-c-select__toggle"

        b.click(f"{selector}:not([disabled]):not([aria-disabled=true])")
        select_entry = f"{selector} + ul button[data-value='{device}']"
        b.click(select_entry)
        b.wait_in_text(f"{selector} .pf-v5-c-select__toggle-text", device)

    def toggle_row_device(self, b, row):
        b.click(f"{self.table_row(row)}-device-select-toggle")

    def check_row_device(self, b, row,  device):
        b.wait_text(f"{self.table_row(row)} .pf-v5-c-select__toggle-text", device)

    def check_row_mountpoint(self, b, row,  mountpoint, isRequired=True):
        if isRequired:
            b.wait_text(f"{self.table_row(row)}-mountpoint", mountpoint)
        else:
            b.wait_val(f"{self.table_row(row)}-mountpoint", mountpoint)

    def check_format_type(self, b, row, format_type):
        self.toggle_row_device(b, row)
        b.wait_in_text(f"{self.table_row(row)} ul li button.pf-m-selected", format_type)
        self.toggle_row_device(b, row)

    def check_device_available(self, b, row, device, available=True):
        self.toggle_row_device(b, row)
        if available:
            b.wait_visible(f"{self.table_row(row)} ul li button:contains({device})")
        else:
            b.wait_not_present(f"{self.table_row(row)} ul li button:contains({device})")
        self.toggle_row_device(b, row)

    def unlock_device(self, b, passphrase, xfail=None):
        # FIXME: https://github.com/patternfly/patternfly-react/issues/9512
        b.wait_visible("#unlock-device-dialog.pf-v5-c-modal-box")
        b.set_input_text("#unlock-device-dialog-luks-password", passphrase)
        b.click("#unlock-device-dialog-submit-btn")
        if xfail:
            b.wait_in_text("#unlock-device-dialog .pf-v5-c-alert", xfail)
            b.click("#unlock-device-dialog-cancel-btn")
        b.wait_not_present("#unlock-device-dialog.pf-v5-c-modal-box")

    def select_reformat(self, b, row, selected=True):
        b.set_checked(f"{self.table_row(row)} td[data-label='Reformat'] input", selected)

    def remove_row(self, b, row):
        b.click(f"{self.table_row(row)} button[aria-label='Remove']")

    def check_reformat(self, b, row, checked):
        checked_selector = "input:checked" if checked else "input:not(:checked)"
        b.wait_visible(f"{self.table_row(row)} td[data-label='Reformat'] {checked_selector}")

    def check_select_disabled(self, b, row):
        b.wait_visible(f"{self.table_row(row)} td[data-label='Device'] .pf-v5-c-select__toggle.pf-m-disabled")

    def check_reformat_disabled(self, b, row):
        b.wait_visible(f"{self.table_row(row)} td[data-label='Reformat'] .pf-v5-c-check__input:disabled")

    def add_mount(self, b):
        b.click("button:contains('Add mount')")

    def unlock_all_encrypted(self, b):
        b.click("button:contains('Unlock')")

    def unlock_all_encrypted_skip(self, b):
        b.click("button:contains('Skip')")

    def assert_inline_error(self, b, text):
        b.wait_in_text(".pf-v5-c-alert.pf-m-inline.pf-m-danger", text)

    def wait_mount_point_table_column_helper(self, b, row, column, text=None, present=True):
        if present:
            b.wait_in_text(f"#mount-point-mapping-table-row-{row}-{column} .pf-v5-c-helper-text__item.pf-m-error", text)
        else:
            b.wait_not_present(f"#mount-point-mapping-table-row-{row}-{column} .pf-v5-c-helper-text__item.pf-m-error")

class TestStorageMountPoints(anacondalib.VirtInstallMachineCase, TestUtils, StorageHelpers):
    efi = False

    @nondestructive
    def testBasic(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b)

        disk = "/dev/vda"
        dev = "vda"
        btrfsname = "btrfstest"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "ext4"), ("10GiB", "btrfs", "-f", "-L", btrfsname), ("", "xfs")])

        s.udevadm_settle()

        i.open()
        i.next()
        s.rescan_disks()

        self.select_mountpoint(b, i, s, [(dev, True)])

        # verify gathered requests
        # root partition is not auto-mapped
        self.check_row_mountpoint(b, 1, "/boot")
        self.check_row_device(b, 1, "Select a device")
        self.check_reformat(b, 1, False)
        self.select_row_device(b, 1, f"{dev}2")
        self.check_format_type(b, 1, "ext4")

        self.check_row_mountpoint(b, 2, "/")
        self.check_row_device(b, 2, "Select a device")
        self.check_reformat(b, 2, True)
        self.select_row_device(b, 2, f"btrfstest")
        self.check_format_type(b, 2, "btrfs")

        self.add_mount(b)
        self.select_row_device(b, 3, f"{dev}4")
        self.check_reformat(b, 3, False)
        self.select_row_mountpoint(b, 3, "/home")
        self.check_format_type(b, 3, "xfs")

        # Toggle reformat option
        self.select_reformat(b, 1)
        self.check_reformat(b, 1, True)

        b.assert_pixels(
            "#app",
            "mount-point-mapping-table",
            wait_animations=False,
        )

        i.next()

        # verify review screen
        r.check_disk(dev, "16.1 GB vda (0x1af4)")

        r.check_disk_row(dev, 1, "vda2, 1.07 GB: format as ext4, /boot")
        r.check_disk_row(dev, 2, "btrfstest, 10.7 GB: format as btrfs, /")
        r.check_disk_row(dev, 3, "vda4, 4.29 GB: mount, /home")

        applied_partitioning = s.dbus_get_applied_partitioning()

        # When adding a new partition a new partitioning should be created
        i.back(previous_page=i.steps.CUSTOM_MOUNT_POINT)
        i.back()

        m.execute(f"sgdisk --new=0:0:0 {disk}")
        s.rescan_disks()
        self.select_mountpoint(b, i, s, [(dev, True)])
        self.check_row_device(b, 1, "Select a device")
        self.check_row_device(b, 2, "Select a device")
        self.select_row_device(b, 1, f"{dev}2")
        self.select_row_device(b, 2, f"btrfstest")

        i.next()
        new_applied_partitioning = s.dbus_get_applied_partitioning()
        self.assertNotEqual(new_applied_partitioning, applied_partitioning)

    @nondestructive
    def testNoRootMountPoint(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        # BIOS boot /boot on ext4 / on xfs /home on btrfs
        disk = "/dev/vda"
        dev = "vda"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "ext4"), ("10GiB", "xfs"), ("", "ext4")])
        s.udevadm_settle()

        i.open()
        i.next()
        s.rescan_disks()

        self.select_mountpoint(b, i, s, [(dev, True)])

        # verify gathered requests
        self.select_row_device(b, 1, f"{dev}2")
        self.check_format_type(b, 1, "ext4")
        self.check_row_mountpoint(b, 1, "/boot")
        self.check_reformat(b, 1, False)

        self.check_row_mountpoint(b, 2, "/")
        self.check_row_device(b, 2, "Select a device")
        self.check_reformat(b, 2, True)

        self.add_mount(b)
        self.select_row_device(b, 3, f"{dev}4")
        self.check_format_type(b, 3, "ext4")
        self.select_row_mountpoint(b, 3, "/home")
        self.check_reformat(b, 3, False)

        i.check_next_disabled()

    def testMultipleDisks(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b)

        m.add_disk(10)

        # BIOS boot partition, /boot partition, /
        disk1 = "/dev/vda"
        dev1 = "vda"
        s.partition_disk(disk1, [("1MiB", "biosboot"), ("1GB", "xfs"), ("", "xfs")])

        # /dev/vdb1 /home partition
        disk2 = "/dev/vdb"
        dev2 = "vdb"
        s.partition_disk(disk2, [("", "xfs")])
        s.udevadm_settle()

        # Select first only vdb disk and verify that the partitioning request is correct
        i.open()
        i.next()

        s.rescan_disks()

        self.select_mountpoint(b, i, s, [(dev1, False), (dev2, True)])

        self.check_device_available(b, 1, "vda2", False)
        self.check_device_available(b, 1, "vdb1")

        # Go back and change the disk selection. The partitioning should be re-created
        i.back()

        b.click("#installation-method-disk-selector-clear")
        self.select_mountpoint(b, i, s, [(dev1, True), (dev2, True)])

        self.check_device_available(b, 1, "vda2", True)
        self.check_device_available(b, 1, "vdb1")

        self.select_row_device(b, 1, f"{dev1}2")
        self.check_format_type(b, 1, "xfs")
        self.check_row_mountpoint(b, 1, "/boot")
        self.check_reformat(b, 1, False)

        self.select_row_device(b, 2, f"{dev1}3")
        self.check_format_type(b, 2, "xfs")
        self.check_row_mountpoint(b, 2, "/")
        self.check_reformat(b, 2, True)

        self.add_mount(b)
        self.select_row_device(b, 3, f"{dev2}1")
        self.check_format_type(b, 3, "xfs")
        self.select_row_mountpoint(b, 3, "/home")
        self.check_reformat(b, 3, False)

        i.next()

        # verify review screen
        disk = "vda"
        r.check_disk(disk, "16.1 GB vda (0x1af4)")
        r.check_disk_row(disk, 1, "vda2, 1.07 GB: mount, /boot")
        r.check_disk_row(disk, 2, "vda3, 15.0 GB: format as xfs, /")

        disk = "vdb"
        r.check_disk(disk, "10.7 GB vdb (0x1af4)")
        r.check_disk_row(disk, 1, "vdb1, 10.7 GB: mount, /home")

        b.assert_pixels(
            "#app",
            "review-multiple-disks",
            wait_animations=False,
        )

    @nondestructive
    def testEncryptedUnlock(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b)

        # BIOS boot partition, /boot partition, /
        disk1 = "/dev/vda"
        dev1 = "vda"
        s.partition_disk(disk1, [("1MiB", "biosboot"), ("1GB", "xfs"), ("1GB", "xfs"), ("", "xfs")])
        m.execute(f"""
        echo einszweidrei | cryptsetup luksFormat {disk1}3
        echo einszweidrei | cryptsetup luksOpen {disk1}3 encrypted-vol
        mkfs.xfs -f /dev/mapper/encrypted-vol
        cryptsetup luksClose encrypted-vol
        echo einszweidreivier | cryptsetup luksFormat {disk1}4
        echo einszweidreivier | cryptsetup luksOpen {disk1}4 encrypted-vol2
        mkfs.xfs -f /dev/mapper/encrypted-vol2
        cryptsetup luksClose encrypted-vol2
        """)
        s.udevadm_settle()

        i.open()
        i.next()
        s.rescan_disks()

        self.select_mountpoint(b, i, s, [(dev1, True)])

        self.unlock_all_encrypted(b)
        self.unlock_device(b, "1234", "Some LUKS devices were not unlocked")

        self.unlock_all_encrypted_skip(b)
        b.wait_not_present("button:contains(Unlock)")

        i.back()
        i.next(next_page=i.steps.CUSTOM_MOUNT_POINT)

        self.unlock_all_encrypted(b)
        self.unlock_device(b, "einszweidrei", "Some LUKS devices were not unlocked")

        self.unlock_all_encrypted_skip(b)
        b.wait_not_present("button:contains(Unlock)")

        i.back()
        i.next(next_page=i.steps.CUSTOM_MOUNT_POINT)

        self.unlock_all_encrypted(b)
        self.unlock_device(b, "einszweidreivier")
        b.wait_not_present("#mount-point-mapping-table tbody tr:nth-child(4) td[data-label='Format type'] #unlock-luks-btn")

        self.check_row_mountpoint(b, 1, "/boot")
        self.select_row_device(b, 1, f"{dev1}2")

        self.check_row_mountpoint(b, 2, "/")
        selector = "#mount-point-mapping-table-row-2 .pf-v5-c-select__toggle"
        b.click(f"{selector}:not([disabled]):not([aria-disabled=true])")
        select_entry = f"{selector} + ul li:nth-of-type(3) button"
        b.click(select_entry)
        b.wait_in_text(f"{selector} .pf-v5-c-select__toggle-text", "luks")
        self.check_format_type(b, 2, "xfs")

        i.next()

        r.check_in_disk_row(dev1, 2, "luks-")

    def testEncryptedUnlockRAIDonLUKS(self):
        # RAID on LUKS: partition -> LUKS -> RAID -> filesystem
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b)

        # BIOS boot partition, /boot partition, / on RAID
        disk = "/dev/vda"
        dev = "vda"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "xfs"), ("5GB", None), ("5GB", None)])
        m.execute(f"""
        echo einszweidrei | cryptsetup luksFormat {disk}3
        echo einszweidrei | cryptsetup luksOpen {disk}3 encrypted-vol
        echo einszweidrei | cryptsetup luksFormat {disk}4
        echo einszweidrei | cryptsetup luksOpen {disk}4 encrypted-vol2
        mdadm --create --run encryptedraid --level=raid1 --raid-devices=2 /dev/mapper/encrypted-vol /dev/mapper/encrypted-vol2
        mkfs.xfs /dev/md/encryptedraid
        """)
        s.udevadm_settle()

        i.open()
        i.next()
        s.rescan_disks()

        # select only vda and check that we don't try to unlock the LUKS partition on vdb
        self.select_mountpoint(b, i, s, [(dev, True)])

        self.unlock_all_encrypted(b)
        self.unlock_device(b, "einszweidrei")
        b.wait_not_present("#mount-point-mapping-table tbody tr:nth-child(4) td[data-label='Format type'] #unlock-luks-btn")

        self.check_row_mountpoint(b, 1, "/boot")
        self.select_row_device(b, 1, f"{dev}2")
        self.select_reformat(b, 1)
        self.check_reformat(b, 1, True)

        self.check_row_mountpoint(b, 2, "/")
        self.check_row_device(b, 2, "Select a device")
        self.check_reformat(b, 2, True)
        self.select_row_device(b, 2, "encryptedraid")
        self.check_format_type(b, 2, "xfs")

        i.next()

        r.check_disk(dev, "16.1 GB vda (0x1af4)")

        r.check_disk_row(dev, 1, "vda2, 1.07 GB: format as xfs, /boot")
        r.check_disk_row(dev, 2, "encryptedraid, 5.35 GB: format as xfs, /")

    def testEncryptedUnlockLUKSonRAID(self):
        # LUKS on RAID: partition -> RAID -> LUKS -> filesystem
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b)

        # BIOS boot partition, /boot partition, / on RAID
        disk = "/dev/vda"
        dev = "vda"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "xfs"), ("5GB", None), ("5GB", None)])
        m.execute(f"""
        mdadm --create --run encryptedraid --level=raid1 --raid-devices=2 {disk}3 {disk}4
        echo einszweidrei | cryptsetup luksFormat /dev/md/encryptedraid
        echo einszweidrei | cryptsetup luksOpen /dev/md/encryptedraid encrypted-vol
        mkfs.xfs /dev/mapper/encrypted-vol
        cryptsetup luksClose /dev/mapper/encrypted-vol
        """)
        s.udevadm_settle()

        i.open()
        i.next()
        s.rescan_disks()

        # select only vda and check that we don't try to unlock the LUKS partition on vdb
        self.select_mountpoint(b, i, s, [(dev, True)])

        self.unlock_all_encrypted(b)
        self.unlock_device(b, "einszweidrei")
        b.wait_not_present("#mount-point-mapping-table tbody tr:nth-child(4) td[data-label='Format type'] #unlock-luks-btn")

        self.check_row_mountpoint(b, 1, "/boot")
        self.select_row_device(b, 1, f"{dev}2")
        self.select_reformat(b, 1)
        self.check_reformat(b, 1, True)

        self.check_row_mountpoint(b, 2, "/")
        selector = "#mount-point-mapping-table-row-2 .pf-v5-c-select__toggle"
        b.click(f"{selector}:not([disabled]):not([aria-disabled=true])")
        select_entry = f"{selector} + ul li:nth-of-type(2) button"
        b.click(select_entry)
        b.wait_in_text(f"{selector} .pf-v5-c-select__toggle-text", "luks")
        self.check_format_type(b, 2, "xfs")

        i.next()

        r.check_disk(dev, "16.1 GB vda (0x1af4)")

        r.check_in_disk_row(dev, 2, "luks-")

    @nondestructive
    def testBtrfsSubvolumes(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b)

        disk = "/dev/vda"
        dev = "vda"
        tmp_mount = "/tmp/btrfs-mount-test"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "ext4"), ("", "btrfs")])
        m.execute(f"""
        mkdir -p {tmp_mount}
        mount {disk}3 {tmp_mount}
        btrfs subvolume create {tmp_mount}/root
        btrfs subvolume create {tmp_mount}/home
        btrfs subvolume create {tmp_mount}/unused
        btrfs subvolume snapshot {tmp_mount}/root {tmp_mount}/snapshot1
        umount {tmp_mount}
        rmdir {tmp_mount}
        """)

        s.udevadm_settle()

        i.open()
        i.next()
        s.rescan_disks()

        self.select_mountpoint(b, i, s, [(dev, True)])

        # btrfs snapshots should not be available
        self.check_device_available(b, 1, "snapshot1", False)

        # verify gathered requests
        # root partition is not auto-mapped
        self.check_row_mountpoint(b, 1, "/boot")
        self.check_row_device(b, 1, "Select a device")
        self.check_reformat(b, 1, False)
        self.select_row_device(b, 1, f"{dev}2")
        self.check_format_type(b, 1, "ext4")

        self.check_row_mountpoint(b, 2, "/")
        self.check_row_device(b, 2, "Select a device")
        self.check_reformat(b, 2, True)
        self.select_row_device(b, 2, "root")
        self.check_format_type(b, 2, "btrfs")

        self.add_mount(b)
        self.select_row_device(b, 3, "home")
        self.check_reformat(b, 3, False)
        self.select_row_mountpoint(b, 3, "/home")
        self.check_format_type(b, 3, "btrfs")

        # Toggle reformat option
        self.select_reformat(b, 1)
        self.check_reformat(b, 1, True)

        i.next()

        # verify review screen
        r.check_disk(dev, "16.1 GB vda (0x1af4)")

        r.check_disk_row(dev, 1, "vda2, 1.07 GB: format as ext4, /boot")
        r.check_disk_row(dev, 2, "root, 15.0 GB: format as btrfs, /")
        r.check_disk_row(dev, 3, "home, 15.0 GB: mount, /home")
        r.check_disk_row_not_present(dev, f"unused")

        i.back(previous_page=i.steps.CUSTOM_MOUNT_POINT)
        i.back()

        # Checks for nested btrfs subvolume
        tmp_mount = "/tmp/btrfs-mount-test"
        m.execute(f"""
        mkdir -p {tmp_mount}
        mount {disk}3 {tmp_mount}
        btrfs subvolume create {tmp_mount}/home/Movies
        btrfs subvolume create {tmp_mount}/home/Movies/Good_Movies
        btrfs subvolume create {tmp_mount}/home/Movies/Bad_Movies
        umount {tmp_mount}
        rmdir {tmp_mount}
        """)
        s.rescan_disks()
        self.select_mountpoint(b, i, s, [(dev, True)])

        self.select_row_device(b, 1, f"{dev}2")
        self.select_row_device(b, 2, "root")
        self.add_mount(b)
        self.select_row_device(b, 3, "home")
        self.select_row_mountpoint(b, 3, "/home")
        self.add_mount(b)
        self.select_row_device(b, 4, "home/Movies")
        self.select_row_mountpoint(b, 4, "/home/Movies")
        self.add_mount(b)
        self.select_row_device(b, 5, "home/Movies/Good_Movies")
        self.select_row_mountpoint(b, 5, "/home/Movies/Good_Movies")
        self.add_mount(b)
        self.select_row_device(b, 6, "home/Movies/Bad_Movies")
        self.select_row_mountpoint(b, 6, "/home/Movies/Bad_Movies")

        # No error when no devices are reformatted
        for row in range(3, 6):
            self.wait_mount_point_table_column_helper(b, row, "format", present=False)

        # When parent is re-formatted all child devices must be reformatted
        self.select_row_device(b, 4, "home/Movies")
        self.select_reformat(b, 4)
        self.wait_mount_point_table_column_helper(b, 4, "format", text="Mismatch")
        self.select_reformat(b, 5)
        self.select_reformat(b, 6)
        self.wait_mount_point_table_column_helper(b, 4, "format", present=False)

        # Check also that the rules apply to children deeper in the device tree
        self.select_reformat(b, 3)
        self.wait_mount_point_table_column_helper(b, 3, "format", present=False)
        self.select_reformat(b, 6, False)
        self.wait_mount_point_table_column_helper(b, 3, "format", text="Mismatch")

        # When parent is re-formmated all child devices should be
        # * either also reformatted if selected
        # * either not selected (not part of the mountpoint assignment table)
        self.remove_row(b, 5)
        self.remove_row(b, 5)
        self.wait_mount_point_table_column_helper(b, 3, "format", present=False)
        self.wait_mount_point_table_column_helper(b, 4, "format", present=False)

        i.check_next_disabled(False)

    def testUnsupportedStorageConfiguration(self):
        # Prevent the user from performing an installation if multiple devices exist with the same name
        # https://bugzilla.redhat.com/show_bug.cgi?id=2237878
        # TODO: Make the test nondestructive
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b)

        disk = "/dev/vda"
        dev = "vda"
        tmp_mount = "/tmp/btrfs-mount-test"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "btrfs"), ("", "btrfs")])
        m.execute(f"""
        mkdir -p {tmp_mount}

        mount {disk}2 {tmp_mount}
        btrfs subvolume create {tmp_mount}/home
        umount {tmp_mount}

        mount {disk}3 {tmp_mount}
        btrfs subvolume create {tmp_mount}/home
        umount {tmp_mount}
        rmdir {tmp_mount}
        """)

        s.udevadm_settle()

        i.open()
        i.next()
        s.rescan_disks()
        s.wait_scenario_available("mount-point-mapping", False)

    @nondestructive
    def testLVM(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b)

        vgname = "fedoravg"

        self.addCleanup(m.execute, f"vgremove -y -ff {vgname}")

        disk = "/dev/vda"
        dev = "vda"
        s.partition_disk(disk, [("1MiB", "biosboot"), ("1GB", "ext4"), ("", None)])
        m.execute(f"""
        vgcreate -y -f {vgname} {disk}3
        lvcreate -y -l40%FREE -n root {vgname}
        mkfs.ext4 -F /dev/{vgname}/root
        lvcreate -y -l90%FREE -n home {vgname}
        mkfs.ext4 -F /dev/{vgname}/home
        lvcreate -y -l100%FREE -n swap {vgname}
        mkswap /dev/{vgname}/swap
        """)

        s.udevadm_settle()

        i.open()
        i.next()
        s.rescan_disks()

        self.select_mountpoint(b, i, s, [(dev, True)])

        # verify gathered requests
        # root partition is not auto-mapped
        self.check_row_mountpoint(b, 1, "/boot")
        self.check_row_device(b, 1, "Select a device")
        self.check_reformat(b, 1, False)
        self.select_row_device(b, 1, f"{dev}2")
        self.check_format_type(b, 1, "ext4")

        self.check_row_mountpoint(b, 2, "/")
        self.check_row_device(b, 2, "Select a device")
        self.check_reformat(b, 2, True)
        self.select_row_device(b, 2, f"{vgname}-root")
        self.check_format_type(b, 2, "ext4")

        self.add_mount(b)
        self.select_row_device(b, 3, f"{vgname}-home")
        self.check_reformat(b, 3, False)
        self.select_row_mountpoint(b, 3, "/home")
        self.check_format_type(b, 3, "ext4")

        self.add_mount(b)
        self.select_row_device(b, 4, f"{vgname}-swap")
        self.check_reformat(b, 4, False)
        self.check_row_mountpoint(b, 4, "swap")
        self.check_format_type(b, 4, "swap")

        # Toggle reformat option
        self.select_reformat(b, 1)
        self.check_reformat(b, 1, True)

        i.next()

        # verify review screen
        disk = "vda"
        r.check_disk(disk, "16.1 GB vda (0x1af4)")

        r.check_disk_row(disk, 1, "vda2, 1.07 GB: format as ext4, /boot")
        r.check_disk_row(disk, 2, f"{vgname}-root, 6.01 GB: format as ext4, /")
        r.check_disk_row(disk, 3, f"{vgname}-home, 8.12 GB: mount, /home")
        r.check_disk_row(disk, 4, f"{vgname}-swap, 902 MB: mount, swap")

        i.back(previous_page=i.steps.CUSTOM_MOUNT_POINT)

        # remove the /home row and check that row 3 is now swap
        self.remove_row(b, 3)

        self.check_row_mountpoint(b, 3, "swap")
        self.check_row_device(b, 3, f"{vgname}-swap")

        i.next()

        # verify review screen
        disk = "vda"
        r.check_disk(disk, "16.1 GB vda (0x1af4)")

        r.check_disk_row(disk, 1, "vda2, 1.07 GB: mount, /boot")
        r.check_disk_row(disk, 2, f"{vgname}-root, 6.01 GB: format as ext4, /")
        r.check_disk_row(disk, 3, f"{vgname}-swap, 902 MB: mount, swap")

    @nondestructive
    def testUnusableFormats(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)

        disk = "/dev/vda"
        dev = "vda"
        s.partition_disk(disk, [("1GB", "udf"), ("1GB", None), ("1GB", "lvmpv")])
        s.udevadm_settle()

        i.open()
        i.next()
        s.rescan_disks()

        self.select_mountpoint(b, i, s, [(dev, True)])

        # UDF filesystem cannot be reformatted by blivet
        self.add_mount(b)
        self.select_row_device(b, 3, f"{dev}1")
        self.select_row_mountpoint(b, 3, "/data")
        self.check_format_type(b, 3, "udf")
        self.select_reformat(b, 3)
        self.wait_mount_point_table_column_helper(b, 3, "format", text="Selected")

        # unformatted and unmountable devices should not be available
        self.check_device_available(b, 1, f"{dev}2", False)
        self.check_device_available(b, 1, f"{dev}3", False)


class TestStorageMountPointsEFI(anacondalib.VirtInstallMachineCase, TestUtils):
    efi = True

    def testBasic(self):
        b = self.browser
        m = self.machine
        i = Installer(b, m)
        s = Storage(b, m)
        r = Review(b)

        disk = "/dev/vda"
        dev = "vda"
        s.partition_disk(disk, [("500MiB", "efi"), ("1GB", "ext4"), ("", "xfs")])

        s.udevadm_settle()

        i.open()
        i.next()
        s.rescan_disks()

        self.select_mountpoint(b, i, s, [(dev, True)])

        # verify gathered requests
        # root partition is not auto-mapped
        self.check_row_mountpoint(b, 1, "/boot")
        self.check_row_device(b, 1, "Select a device")
        self.check_reformat(b, 1, False)
        self.select_row_device(b, 1, f"{dev}2")
        self.check_format_type(b, 1, "ext4")

        self.check_row_mountpoint(b, 2, "/")
        self.check_row_device(b, 2, "Select a device")
        self.check_reformat(b, 2, True)
        self.select_row_device(b, 2, f"{dev}3")
        self.check_format_type(b, 2, "xfs")

        self.check_row_mountpoint(b, 3, "/boot/efi")
        self.check_row_device(b, 3, "Select a device")
        self.check_reformat(b, 3, False)
        self.select_row_device(b, 3, f"{dev}1")
        self.check_format_type(b, 3, "EFI System Partition")

        i.next()

        # verify review screen
        r.check_disk(dev, "16.1 GB vda (0x1af4)")

        r.check_disk_row(dev, 1, "vda1, 524 MB: mount, /boot/efi")
        r.check_disk_row(dev, 2, "vda2, 1.07 GB: mount, /boot")
        r.check_disk_row(dev, 3, "vda3, 14.5 GB: format as xfs, /")


if __name__ == '__main__':
    test_main()
