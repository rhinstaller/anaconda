#!/bin/bash

PATH=$PATH:/sbin:/usr/sbin

usage () {
	echo "usage: mk-images <pkgsrc> <toplevel> <template> <buildarch>"
    exit 0
}

if [ -z "$1" -o -z "$2" -o -z "$3" -o -z "$4" ]; then usage; fi

TOPDIR=$(echo $0 | sed "s,/[^/]*$,,")
if [ $TOPDIR = $0 ]; then
    $TOPDIR="."
fi

TOPDIR=$(cd $TOPDIR; pwd)

# Set, verify, and create paths
    KERNELPATH=$1
    TOPDESTPATH=$2
    IMAGEPATH=$2/images
    FULLMODPATH=/tmp/instimagemods.$$
    FINALFULLMODPATH=$2/RedHat/instimage/modules
    INSTIMGPATH=$2/RedHat/base
    INSTIMGTEMPLATE=$3
    IMGPATH=$2/RedHat/instimage
    KERNELROOT=/tmp/updboot.kernel.$$
    MODDEPS=$KERNELROOT/moddeps
    BUILDARCH=$4

    KERNELNAME=vmlinuz
    if [ "$BUILDARCH" = ia64 ]; then
	KERNELNAME=vmlinux
    fi
    
    if [ "$BUILDARCH" = "sparc64" ]; then
	BASEARCH=sparc
    else
	BASEARCH=$BUILDARCH
    fi

    if [ ! -d "$1" ]; then
	LATEST="rsh porkchop latest --arch $BUILDARCH"
    else
	LATEST=findPackage
    fi

    rm -rf $IMAGEPATH
    rm -rf $FULLMODPATH
    rm -rf $FINALFULLMODPATH
    rm -rf $KERNELROOT
    mkdir -p $IMAGEPATH
    mkdir -p $FULLMODPATH
    mkdir -p $FINALFULLMODPATH
    mkdir -p $KERNELROOT
    mkdir -p $INSTIMGPATH

# Stuff that we need
    TRIMPCITABLE=$IMGPATH/usr/lib/anaconda-runtime/trimpcitable
    KEYMAPS=$IMGPATH/usr/lib/anaconda-runtime/keymaps-${BASEARCH}
    FONTS=$IMGPATH/usr/lib/anaconda-runtime/fonts-${BASEARCH}
    GETMODDEPS=$IMGPATH/usr/lib/anaconda-runtime/moddeps
    MODLIST=$IMGPATH/usr/lib/anaconda-runtime/modlist
    MODINFO=$IMGPATH/usr/lib/anaconda-runtime/loader/module-info
    FILTERMODDEPS=$IMGPATH/usr/lib/anaconda-runtime/filtermoddeps
    LOADERBINDIR=$IMGPATH/usr/lib/anaconda-runtime/loader
    BOOTDISKDIR=$IMGPATH/usr/lib/anaconda-runtime/boot
    LANGTABLE=$IMGPATH/usr/lib/anaconda/lang-table
    PCITABLE=$IMGPATH/usr/share/kudzu/pcitable
    CACHE=$KERNELROOT/lib/modules/.cache
    MODULESUSED=$KERNELROOT/modules-used

    touch $MODULESUSED

    REQUIREMENTS="$TRIMPCITABLE $PCITABLE $GETMODDEPS $MODINFO
		  $FILTERMODDEPS $LANGTABLE $KEYMAPS"

    dieLater=
    for n in $REQUIREMENTS; do
	if [ ! -f $n ]; then
	    echo "$n doesn't exist"
	    dieLater=1
	fi
    done

    for n in $BOOTDISKDIR; do
	if [ ! -d $n ]; then
	    echo "$n doesn't exist"
	    dieLater=1
	fi
    done

    if [ -n "$dieLater" ]; then exit 1; fi

findPackage() {
    dir=$1
    name=$2
    
    for n in $dir/$name*{${BUILDARCH},noarch}.rpm; do
	thisName=$(rpm --qf '%{NAME}' -qp $n)
	if [ -z "$thisName" ]; then
	    return
	fi
	if [ $thisName = $name ]; then
	    echo $n
	    return
	fi
    done

    echo "cannot find package $name in path $dir" >&2
    kill -9 $$
}

findmodule () {
    if [ ! -f $CACHE ]; then
        find $KERNELROOT/lib/modules > $CACHE
    fi
    
    grep "/$1\.o" $CACHE
}

rundepmod () {
    what=$1
    final=$2

    exclpattern="tc90x|FPT|BusLogic|Pci2000|Pci2220i"

    $FAKEARCH /sbin/depmod -e -i -m $KERNELROOT/boot/System.map-$version \
	    $what > $final.foo 2>&1 | 
	    egrep -v "modprobe: (${exclpattern}) multiply defined"

    # For paride we need to change this:
    # aten: paride
    # ...
    # paride: parport
    # imm: parport
    # ppa: parport
    # parport_pc: parport
    # pcd: paride
    #
    # into this:
    # aten: paride
    # ...
    # paride: parport_pc
    # imm: parport_pc
    # ppa: parport_pc
    # parport_pc: parport
    # pcd: aten ...
    #
    # So we use an ugly hack. :-(

    PARIDE="aten bpck comm dstr epat epia fit2 fit3 friq frpw kbic ktti on20 on26"
    cat $final.foo | $FILTERMODDEPS | sed -e 's/\.o//g' \
	  -e 's/: parport$/: parport_pc/g' \
	  -e 's/^\(parport_pc: parport\)_pc$/\1/' \
	  -e "s/^pcd:.*/pcd: $PARIDE/" > $final 
    rm -f $final.foo
}

getmoddeps () {
    what=$1
    final=$2

    egrep $(echo $what | sed 's/\.o  */|^/g;s/\.o$//') $MODDEPS > $final
}

intcopymodules () {
    dir=$2

    for n in $1; do
	m=$(findmodule $n)
	if [ -z "$m" ]; then
            echo "Module $n not found in kernel rpm"
        else 
	    echo $n >> $MODULESUSED
	    if ! cp $m $dir ; then
		echo "Failed to copy $m to $dir (for module $n)"
	    fi
        fi
    done
}

resdeps () {
    $GETMODDEPS -m $MODDEPS $* 2>&1
    if [ $? != "0" ] ; then
	kill -9 $$
    fi	
    list=`$GETMODDEPS -m $MODDEPS $*`
    items=$(for n in $* $list; do echo $n; done | sort -u)
    echo $items
}

expandModuleSet() {
    SET=""
    for name in $1; do
	char=$(echo $name | cut -c1)
        if [ $char = '=' ]; then
	    NAME=$(echo $name | cut -c2-)
	    SET="$SET $($MODLIST --modinfo-file $MODINFO $NAME)"
	elif [ $char = '+' ]; then
	    NAME=$(echo $name | cut -c2-)

	    # all of the modules of this type
	    $MODLIST --modinfo-file $MODINFO $NAME > /tmp/emsAll.$$
	    # the modules used that are of this type
	    sort -u $MODULESUSED | cat - /tmp/emsAll.$$ | sort | 
		    uniq -d > /tmp/emsUsed.$$
	    # the modules that are of this type, but not used
	    SET="$SET $(cat /tmp/emsAll.$$ /tmp/emsUsed.$$ | sort | uniq -u)"

	    rm -f /tmp/emsAll.$$ /tmp/emsUsed.$$
	else
	    SET="$SET $name"
	fi
    done

    echo $SET
}

makemoduleball() {
    unset MMB_DD
    MMB_MODINFO="module-info"
    MMB_NAME="modules.cgz"

    while [ x$(echo $1 | cut -c1-2) = x"--" ]; do
	if [ "$1" = "--dd" ]; then
	    MMB_DD="$2"
	    shift; shift
	    MMB_MODINFO="modinfo"
	    continue
	elif [ "$1" = "--name" ]; then
	    MMB_NAME="$2"
	    shift; shift
	    continue
	fi
	echo "unknown option passed to $0"
	exit 1
    done

    MMB_DIR=$1
    MMB_MODULESET=$(resdeps $2)

    rm -rf $MMB_DIR/modules $MMB_DIR/$MMB_NAME $MMB_DIR/modules.dep \
	   $MMB_DIR/pcitable $MMB_DIR/$MMB_MODINFO
    mkdir -p $MMB_DIR/modules

    intcopymodules "$MMB_MODULESET" $MMB_DIR/modules

    pushd $MMB_DIR/modules > /dev/null

    $MODLIST --modinfo-file $MODINFO --ignore-missing --modinfo \
	$MMB_MODULESET > ../$MMB_MODINFO

    getmoddeps "*.o" ../modules.dep

    # create the pcitable
    $TRIMPCITABLE *.o < $PCITABLE > ../pcitable

    if [ -n "$MMB_DD" ]; then
	echo $MMB_DD > $MMB_DIR/rhdd-6.1
    fi

    mkdir $version
    mv *.o $version

    find $version -type f | cpio --quiet -H crc -o | gzip -9 > ../$MMB_NAME
    cd ..
    rm -rf modules
    popd  > /dev/null
}

makemainmodules() {
    modlist=`expandModuleSet "$1"`

    if [ -n "$2" ]; then
	extraargs="--name $2"
    fi

    rm -rf $FULLMODPATH
    rm -rf $FINALFULLMODPATH

    makemoduleball $extraargs $FULLMODPATH "$modlist"
    cp -ar $FULLMODPATH $FINALFULLMODPATH
    rm -rf $FULLMODPATH
}

makeinitrd() {
    EXTRAINITRDPATH=""
    PCMCIA=""
    INITRDSIZE=""
    KEEP=""
    PADSIZE=""
    LOADERBIN=""
    INITRDMODULES=""
    MODULEBALLNAME="modules.cgz"
    MYLANGTABLE=$LANGTABLE
    MYLOADERTR=loader.tr
    JAPANESE=""
    while [ x$(echo $1 | cut -c1-2) = x"--" ]; do
	if [ $1 = "--initrdto" ]; then
	    EXTRAINITRDPATH=$2
	    shift; shift
	    continue
	elif [ $1 = "--pcmcia" ]; then
	    PCMCIA=yes
	    shift
	    continue
	elif [ $1 = "--keep" ]; then
	    KEEP=yes
	    shift
	    continue
	elif [ $1 = "--initrdsize" ]; then
	    INITRDSIZE=$2
	    shift; shift
	    continue
	elif [ $1 = "--padsize" ]; then
	    PADSIZE=$2
	    shift; shift
	    continue
	elif [ $1 = "--loaderbin" ]; then
	    LOADERBIN=$2
	    shift; shift
	    continue
	elif [ $1 = "--modules" ]; then
	    LOADERMODULES=$2
	    shift; shift
	    continue
	elif [ $1 = "--moduleballname" ]; then
	    MODULEBALLNAME=$2
	    shift; shift
	    continue
	elif [ $1 = "--japanese" ]; then
	    MYLANGTABLE=$IMGPATH/usr/lib/anaconda/lang-table-kon
	    MYLOADERTR=kon-loader.tr
	    JAPANESE=1
	    shift; 
	    continue
	fi
	echo "Unknown option passed to makeinitrd"
	exit 1
    done
    if [ -z "$LOADERBIN" ]; then
	echo "no loader binary specified!" >&2
	exit 1
    fi
    if [ -z "$LOADERMODULES" ]; then
	echo "warning: no loader modules specified!" >&2
    fi
    if [ -z "$INITRDSIZE" ]; then
	echo "I don't know how big to make the initrd image!" >&2
	exit 1
    fi

    MBD_DIR=/tmp/makebootdisk.dir.$$
    MBD_FSIMAGE=/tmp/makebootdisk.initrdimage.$$
    MBD_MNTPOINT=/tmp/makebootdisk.mount.$$
    MBD_TMPIMAGE=/tmp/makebootdisk.image.$$
    MBD_BOOTTREE=/tmp/makebootdisk.tree.$$
    INITBIN=init

    rm -rf $MBD_DIR MBD_FSIMAGE
    mkdir -p $MBD_DIR/modules
    mkdir -p $MBD_DIR/sbin
    mkdir -p $MBD_DIR/dev/pts
    mkdir -p $MBD_DIR/dev/input
    mkdir -p $MBD_DIR/etc
    mkdir -p $MBD_DIR/proc
    mkdir -p $MBD_DIR/tmp
    mkdir -p $MBD_DIR/etc/terminfo/l
    mkdir -p $MBD_DIR/var/state
    ln -s /tmp $MBD_DIR/var/state/xkb

    if [ -n "$LOADERMODULES" ]; then
	MODSET=`expandModuleSet "$LOADERMODULES"`
        makemoduleball --name $MODULEBALLNAME $MBD_DIR/modules "$MODSET"
    fi

    cat > $MBD_DIR/etc/passwd << EOF
    root::0:0:root:/:/bin/bash
EOF

    install -s -m 755 $LOADERBINDIR/$LOADERBIN $MBD_DIR/sbin/loader
    install -s -m 755 $LOADERBINDIR/$INITBIN $MBD_DIR/sbin
    install -m 644 $KEYMAPS $MBD_DIR/etc/keymaps.gz
    install -m 644 $FONTS $MBD_DIR/etc/fonts.cgz
    install -m 644 $MYLANGTABLE $MBD_DIR/etc/lang-table
    install -m 644 $LOADERBINDIR/$MYLOADERTR $MBD_DIR/etc/loader.tr
    install -m 644 $IMGPATH/usr/share/terminfo/l/linux $MBD_DIR/etc/terminfo/l/linux
    if [ -n "$JAPANESE" ]; then
        mkdir -p $MBD_DIR/etc/terminfo/k
        install -m 644 $IMGPATH/usr/share/terminfo/k/kon $MBD_DIR/etc/terminfo/k/kon
	install -m 644 $LOADERBINDIR/kon.cfg $MBD_DIR/etc
	install -m 644 $LOADERBINDIR/minikon.fnt $MBD_DIR/etc
	ln -s loader $MBD_DIR/sbin/continue
    fi

    if [ -n "$PCMCIA" ]; then
	mkdir -p $MBD_BOOTTREE/etc
	cp -a $KERNELROOT/etc/pcmcia $MBD_DIR/etc
    fi

    for n in insmod rmmod modprobe; do
	ln -s loader $MBD_DIR/sbin/$n
    done

    ln -s /usr/bin/sh $MBD_DIR/sbin/sh
    ln -s /sbin/init $MBD_DIR/linuxrc
    ln -s /proc/mounts $MBD_DIR/etc/mtab
    ln -s sbin $MBD_DIR/bin

    awk '{ printf("mknod %s/dev/%s %s %s %s\n", $1, $2, $3, $4, $5);
	   printf("chmod %s %s/dev/%s\n", $6, $1, $2);
	   printf("chown %s %s/dev/%s\n", $7, $1, $2); 
	 }' <<EOF | sh
	$MBD_DIR console c 5 1 600 root:root
	$MBD_DIR ttyS0 c 4 64 600 root:root
	$MBD_DIR ttyS1 c 4 65 600 root:root
	$MBD_DIR ttyS2 c 4 66 600 root:root
	$MBD_DIR ttyS3 c 4 67 600 root:root
	$MBD_DIR psaux c 10 1 644 root:root
	$MBD_DIR null c 1 3 666 root:root
	$MBD_DIR zero c 1 5 666 root:root
	$MBD_DIR md0 b 9 0 644 root:root
	$MBD_DIR mem c 1 1 600 root:root
	$MBD_DIR ram b 1 1 640 root:root
	$MBD_DIR ptmx c 5 2 666 root:root
	$MBD_DIR tty0 c 4 0 600 root:tty
	$MBD_DIR tty1 c 4 1 600 root:tty
	$MBD_DIR tty2 c 4 2 600 root:tty
	$MBD_DIR tty3 c 4 3 600 root:tty
	$MBD_DIR tty4 c 4 4 600 root:tty
	$MBD_DIR tty5 c 4 5 600 root:tty
	$MBD_DIR tty6 c 4 6 600 root:tty
	$MBD_DIR tty7 c 4 7 600 root:tty
	$MBD_DIR tty8 c 4 8 600 root:tty
	$MBD_DIR tty9 c 4 9 600 root:tty
	$MBD_DIR fb0 c 29 0 600 root:tty
	$MBD_DIR fb1 c 29 32 600 root:tty
	$MBD_DIR fb2 c 29 64 600 root:tty
	$MBD_DIR fb3 c 29 96 600 root:tty
	$MBD_DIR fb4 c 29 128 600 root:tty
	$MBD_DIR fb5 c 29 160 600 root:tty
	$MBD_DIR fb6 c 29 192 600 root:tty
	$MBD_DIR fb7 c 29 224 600 root:tty
	$MBD_DIR openprom c 10 139 644 root:root
	$MBD_DIR sunmouse c 10 6 644 root:root
	$MBD_DIR kbd c 11 0 644 root:root
	$MBD_DIR ptyp0 c 2 0 644 root:root
	$MBD_DIR ttyp0 c 3 0 644 root:root
	$MBD_DIR agpgart c 10 175 664 root:root
	$MBD_DIR input/mice c 13 63 664 root:root
EOF
    ln -s fb0 $MBD_DIR/dev/fb

cat > $MBD_DIR/.profile <<EOF
PATH=/bin:/usr/bin:/usr/sbin:/usr/X11R6/bin:/mnt/sbin:/mnt/usr/sbin:/mnt/bin:/mnt/usr/bin
export PATH
EOF

    rm -f $MBD_FSIMAGE
    dd if=/dev/zero of=$MBD_FSIMAGE bs=1k count=$INITRDSIZE 2> /dev/null
    echo y | /sbin/mke2fs -i 8096 -q $MBD_FSIMAGE $INITRDSIZE > /dev/null 2>/dev/null

    rm -rf $MBD_MNTPOINT
    mkdir $MBD_MNTPOINT
    mount -o loop -t ext2 $MBD_FSIMAGE $MBD_MNTPOINT
    (cd $MBD_DIR; find . | cpio --quiet -p $MBD_MNTPOINT)

    left=$(df $MBD_MNTPOINT | tail +2)
    left=$(echo $left | awk '{print $4'})

    umount $MBD_MNTPOINT

    mv -f $MBD_FSIMAGE $MBD_FSIMAGE.uncompressed
    gzip -9 < $MBD_FSIMAGE.uncompressed > $MBD_FSIMAGE
    rm -rf $MBD_FSIMAGE.uncompressed $MBD_DIR

    size=$(du $MBD_FSIMAGE | awk '{ print $1 }')

    echo "Wrote $MBD_BOOTTREE (${size}k compressed, ${left}k free)"

    rm -rf $MBD_TMPIMAGE $MBD_BOOTTREE

    if [ -n "$PADSIZE" ]; then
	size=`cat $MBD_FSIMAGE | wc -c`
	filler=`expr $PADSIZE "*" 1024 - $size`
	dd if=/dev/zero bs=$filler count=1 >> $MBD_FSIMAGE 2> /dev/null
    fi

    if [ -n "$EXTRAINITRDPATH" ]; then
	mkdir -p `dirname $EXTRAINITRDPATH`
	cp -a $MBD_FSIMAGE $EXTRAINITRDPATH
    fi

    if [ -z "$KEEP" ]; then
	rm -rf $MBD_TMPIMAGE $MBD_FSIMAGE $MBD_MNTPOINT $MBD_BOOTTREE
    fi
}

makebootdisk() {
    BOOTDISKSIZE=""
    EXTRAKERNELPATH=""
    INITRDFLAGS=""
    MBD_FILENAME=""
    INITRDFILE=""
    while [ x$(echo $1 | cut -c1-2) = x"--" ]; do
	if [ $1 = "--bootdisksize" ]; then
	     BOOTDISKSIZE=$2
	     shift; shift
	     continue
	elif [ $1 = "--kernelto" ]; then
	    EXTRAKERNELPATH=$2
	    shift; shift
	    continue
	elif [ $1 = "--initrdflags" ]; then
	    INITRDFLAGS=$2
	    shift; shift
	    continue
	elif [ $1 = "--initrd" ]; then
	    INITRDFILE=$2
	    shift; shift
	    continue
	elif [ $1 = "--imagename" ]; then
	    MBD_FILENAME=$IMAGEPATH/$2
	    shift; shift
	    continue
	fi
	echo "Unknown option passed to makebootdisk"
	exit 1
    done

    if [ -z "$MBD_FILENAME" ]; then
	echo "No imagename passed"
	exit 1
    fi

    if [ -n "$INITRDFILE" ]; then
	MBD_FSIMAGE="$INITRDFILE"
    elif [ -n "$INITRDFLAGS" ]; then
	eval makeinitrd --keep $INITRDFLAGS
    fi

    mkdir -p $MBD_BOOTTREE

    # provided by the mk-image.$ARCH file
    prepareBootImage

    left=$(df $MBD_BOOTTREE | tail +2)
    left=$(echo $left | awk '{print $4'})

    umount $MBD_BOOTTREE

    if [ -n "$EXTRAKERNELPATH" ]; then
	mkdir -p `dirname $EXTRAKERNELPATH`
	cp -f $KERNELROOT/boot/${KERNELNAME}-* $EXTRAKERNELPATH
    fi

    mkdir -p `dirname $MBD_FILENAME`
    rm -f $MBD_FILENAME
    mv -f $MBD_TMPIMAGE $MBD_FILENAME
    rm -rf $MBD_TMPIMAGE $MBD_MNTPOINT $MBD_BOOTTREE
    if [ -z "$INITRDFILE" ]; then
	rm -f $MBD_FSIMAGE
    fi

    echo "Wrote $MBD_FILENAME (${left}k free)"
}

makeImage () {
    MI_FROM=$1
    MI_SIZE=$2
    MI_TO=$3
    MI_TMPIMAGE=/tmp/makeimage.img.$$
    MI_MNTPOINT=/tmp/makeimage.mnt.$$

    mkdir -p $MI_MNTPOINT

    dd if=/dev/zero of=$MI_TMPIMAGE bs=1k count=$MI_SIZE 2>/dev/null
    echo y | /sbin/mke2fs -i 4096 $MI_TMPIMAGE  > /dev/null 2>/dev/null
    mount -o loop $MI_TMPIMAGE $MI_MNTPOINT
    (cd $MI_FROM; find . | cpio --quiet -p $MI_MNTPOINT)

    left=$(df $MI_MNTPOINT | tail +2)
    left=$(echo $left | awk '{print $4'})

    umount $MI_MNTPOINT
    rmdir $MI_MNTPOINT

    gzip -9 < $MI_TMPIMAGE > $MI_TO

    echo "Wrote $MI_TO (${left}k of ${MI_SIZE}k free)"
}

makeinstimage () {
    SIZE1=4096
    SIZE2=""

    while [ $(echo $1 | cut -c1-2) = "--" ]; do
	if [ $1 = "--size1" ]; then
	    SIZE1=$2
	    shift; shift
	elif [ $1 = "--size2" ]; then
	    SIZE2=$2
	    shift; shift
	fi
    done

    imagename=$1
    modlist=$(expandModuleSet "$2")
    tmpdir=/tmp/instimage.dir.$$

    rm -rf $tmpimage $tmpdir
    mkdir -p $mntpoint $tmpdir

    mkdir -p $tmpdir
    (cd $INSTIMGTEMPLATE; find . | cpio --quiet -p $tmpdir)
    makemoduleball $tmpdir/modules "$modlist"

    if [ -n "$SIZE2" ]; then
	makeImage $tmpdir/usr $SIZE2 $INSTIMGPATH/${imagename}2.img
	rm -rf $tmpdir/usr
    fi

    makeImage $tmpdir $SIZE1 $INSTIMGPATH/${imagename}1.img
    rm -rf $tmpdir
}

findloopdevice () {
    if [ -z "$1" ]; then
	echo "usage: findloopdevice image"
	exit 1
    fi

    for devnum in 0 1 2 3 4 5 6 7 8; do
        if losetup /dev/loop$devnum $1 2>/dev/null ; then break; fi
    done
    echo /dev/loop$devnum
}

makemainimage () {
    imagename=$1
    mmi_tmpimage=/tmp/instimage.img.$$
    mmi_mntpoint=/tmp/instimage.mnt.$$
    
    rm -rf $mmi_tmpimage $mmi_mntpoint
    mkdir $mmi_mntpoint

    SIZE=$(du -sk $IMGPATH | awk '{ print int($1 * 1.1) }')
    if [ -d $IMGPATH/usr/lib/anaconda-runtime ]; then
	ERROR=$(du -sk $IMGPATH/usr/lib/anaconda-runtime | awk '{ print $1 }')
	SIZE=$(expr $SIZE - $ERROR)
    fi
    dd if=/dev/zero bs=1k count=${SIZE} of=$mmi_tmpimage
    echo y | mke2fs $mmi_tmpimage > /dev/null 
    mount -o loop $mmi_tmpimage $mmi_mntpoint

    (cd $IMGPATH; find . | fgrep -v "./usr/lib/anaconda-runtime" |
	    cpio -H crc -o) | (cd $mmi_mntpoint; cpio -iumd)
    umount $mmi_mntpoint

    cp $mmi_tmpimage $INSTIMGPATH/${imagename}.img

    echo "Wrote $INSTIMGPATH/${imagename}.img (${SIZE}k)"

    rm $mmi_tmpimage
    rmdir $mmi_mntpoint
}

makedriverdisk () {
    modlabel=$1
    diskname=$2
    modlist=$(expandModuleSet "$3")
    diskpath=/tmp/makedriverdisk.$$

    rm -rf $diskpath
    mkdir -p $diskpath

    makemoduleball --dd "$modlabel" $diskpath "$modlist"

    size=$(expr 60 + $(du -sk $diskpath | awk '{print $1}'))
    if [ $size -lt 57 ]; then
	size=64
    fi

    dd if=/dev/zero of=/tmp/$diskname.img bs=1k count=$size 2> /dev/null
    echo y | /sbin/mke2fs -i 4096 /tmp/$diskname.img  > /dev/null 2>/dev/null
    mkdir -p /tmp/mkdd.$$
    mount -t ext2 -o loop /tmp/$diskname.img /tmp/mkdd.$$
    rmdir /tmp/mkdd.$$/lost+found
    (cd $diskpath; tar cSpf - .) | (cd /tmp/mkdd.$$; tar xSpf -)
    DIE=""
    diff -upr $diskpath /tmp/mkdd.$$ > /dev/null 2>&1
    if [ $? != 0 ]; then
	echo copy to disk image failed
	ls -l /tmp/mkdd.$$
	echo "disk size: $size"
	ls -l $diskpath
	DIE=1
    fi
    umount /tmp/mkdd.$$
    rm -rf /tmp/mkdd.$$

    if [ -n "$DIE" ]; then
	kill -9 $$
    fi

    cp /tmp/${diskname}.img $IMAGEPATH/${diskname}.img
    rm /tmp/${diskname}.img
    rm -rf $diskpath

    size=$(ls -l $IMAGEPATH/${diskname}.img | awk '{ print $5 }')
    size=$(expr $size / 1024)

    echo "Wrote $IMAGEPATH/${diskname}.img (${size}k)"
}

# Find the kernel, unpack it, and verify it
    kpackage=$($LATEST $KERNELPATH kernel-BOOT)
    vertag=BOOT
    if [ ! -f "$kpackage" ]; then
	echo 'kernel-BOOT does not exist -- using kernel package'
	kpackage=$($LATEST $KERNELPATH kernel)
	vertag=""
    fi

    ppackage=$($LATEST $KERNELPATH kernel-pcmcia-cs)
    if [ ! -f "$ppackage" ]; then
	ppackage=""
    fi

    version=$(rpm --qf '%{VERSION}-%{RELEASE}' -qp $kpackage)${vertag}

    rpm2cpio $kpackage | (cd $KERNELROOT; cpio --quiet -iumd)
    if [ ! -z $ppackage ]; then 
	rpm2cpio $ppackage | (cd $KERNELROOT; cpio --quiet -iumd etc/pcmcia/* ./etc/pcmcia/*)
    fi

    if [ ! -d "$KERNELROOT/lib/modules/$version" ]; then
	echo "$1 is not a valid modules directory" 2>&1
	usage
    fi

    if [ ! -f "$KERNELROOT/boot/${KERNELNAME}-$version" ]; then
	echo "$KERNELROOT/boot/${KERNELNAME}-$version does not exist"
	usage
    fi

    if [ -d $KERNELROOT/lib/modules/$version/pcmcia ]; then
	PCMCIAMODULES=$(cd $KERNELROOT/lib/modules/$version/pcmcia; ls *.o |
	    sed 's/\.o//g')
    fi

    allmods=$(find $KERNELROOT/lib/modules/$version -name *.o)

    rundepmod "$allmods" $MODDEPS
    rm -f $MODDEPS.foo

. $TOPDIR/mk-images.${BUILDARCH}

rm -rf $KERNELROOT
