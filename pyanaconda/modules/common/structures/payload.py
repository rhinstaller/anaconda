#
# DBus structures for the payload data.
#
# Copyright (C) 2020 Red Hat, Inc.
#
# This copyrighted material is made available to anyone wishing to use,
# modify, copy, or redistribute it subject to the terms and conditions of
# the GNU General Public License v.2, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY expressed or implied, including the implied warranties of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.  You should have received a copy of the
# GNU General Public License along with this program; if not, write to the
# Free Software Foundation, Inc., 31 Milk Street #960789 Boston, MA
# 02196 USA.  Any Red Hat trademarks that are incorporated in the
# source code or documentation are not subject to the GNU General Public
# License and may only be used or replicated with the express permission of
# Red Hat, Inc.
#

from dasbus.structure import DBusData
from dasbus.typing import *  # pylint: disable=wildcard-import

from pyanaconda.core.util import join_paths
from pyanaconda.core.constants import URL_TYPE_BASEURL, DNF_DEFAULT_REPO_COST, \
    MULTILIB_POLICY_BEST, RPM_LANGUAGES_ALL, DNF_DEFAULT_TIMEOUT, DNF_DEFAULT_RETRIES

__all__ = ["RepoConfigurationData", "SSLConfigurationData", "PackagesConfigurationData"]


class SSLConfigurationData(DBusData):
    """Structure with SSL configuration settings."""

    def __init__(self):
        self._ca_cert_path = ""
        self._client_cert_path = ""
        self._client_key_path = ""

    @property
    def ca_cert_path(self) -> Str:
        """Get CA certificate path."""
        return self._ca_cert_path

    @ca_cert_path.setter
    def ca_cert_path(self, ca_cert_path: Str):
        self._ca_cert_path = ca_cert_path

    @property
    def client_cert_path(self) -> Str:
        """Get client certificate path."""
        return self._client_cert_path

    @client_cert_path.setter
    def client_cert_path(self, client_cert_path: Str):
        self._client_cert_path = client_cert_path

    @property
    def client_key_path(self) -> Str:
        """Get client key path."""
        return self._client_key_path

    @client_key_path.setter
    def client_key_path(self, client_key_path: Str):
        self._client_key_path = client_key_path

    def is_empty(self):
        """Is this configuration empty?

        :rtype: bool
        """
        return not any([self._ca_cert_path, self._client_cert_path, self._client_key_path])


class RepoConfigurationData(DBusData):
    """Structure to hold repository configuration."""

    def __init__(self):
        self._name = ""
        self._url = ""
        self._type = URL_TYPE_BASEURL
        self._ssl_verification_enabled = True
        self._ssl_configuration = SSLConfigurationData()
        self._proxy = ""
        self._cost = DNF_DEFAULT_REPO_COST
        self._exclude_packages = []
        self._included_packages = []

    @classmethod
    def from_directory(cls, directory_path):
        """Generate RepoConfigurationData url from directory path.

        This will basically add file:/// to the directory and set it to url with a proper type.

        :param str directory_path: directory which will be used to create url
        :return: RepoConfigurationData instance
        """
        data = RepoConfigurationData()

        data.url = join_paths("file:///", directory_path)

        return data

    @property
    def name(self) -> Str:
        """Get name of this repository.

        If name is not set it will be generated by source.
        """
        return self._name

    @name.setter
    def name(self, name: Str):
        self._name = name

    @property
    def url(self) -> Str:
        """Get link to the repository."""
        return self._url

    @url.setter
    def url(self, url: Str):
        self._url = url

    @property
    def type(self) -> Str:
        """Get type of the url.

        Possible values:
        - BASEURL
        - MIRRORLIST
        - METALINK
        """
        return self._type

    @type.setter
    def type(self, url_type: Str):
        self._type = url_type

    @property
    def ssl_verification_enabled(self) -> Bool:
        """Is ssl verification enabled?

        You can disable SSL verification to reach server with certificate
        which is not part of installation environment.
        """
        return self._ssl_verification_enabled

    @ssl_verification_enabled.setter
    def ssl_verification_enabled(self, ssl_verification_enabled: Bool):
        self._ssl_verification_enabled = ssl_verification_enabled

    @property
    def ssl_configuration(self) -> SSLConfigurationData:
        """Inner structure for SSL configuration.

        See SSLConfigurationData for more details.
        """
        return self._ssl_configuration

    @ssl_configuration.setter
    def ssl_configuration(self, ssl_configuration: SSLConfigurationData):
        self._ssl_configuration = ssl_configuration

    @property
    def proxy(self) -> Str:
        """Get proxy URL for this repository.

        :return: a proxy URL
        """
        return self._proxy

    @proxy.setter
    def proxy(self, proxy: Str):
        self._proxy = proxy

    @property
    def cost(self) -> Int:
        """Cost value of this repository.

        The relative cost of accessing this repository. This value is compared when the
        priorities of two repositories are the same. The repository with the lowest cost is picked.

        Default value is 1000.
        """
        return self._cost

    @cost.setter
    def cost(self, cost: Int):
        self._cost = cost

    @property
    def excluded_packages(self) -> List[Str]:
        """Packages which won't be fetched from the repository.

        A list of package names and globs that must not be fetched from this repository.
        This is useful if multiple repositories provide the same package and you
        want to make sure it is not fetched from a particular repository during installation.
        """
        return self._exclude_packages

    @excluded_packages.setter
    def excluded_packages(self, excluded_packages: List[Str]):
        self._exclude_packages = excluded_packages

    @property
    def included_packages(self) -> List[Str]:
        """Get packages which only should be installed from the repository.

        A list of package names and globs that can be pulled from this repository.
        Any other packages provided by the repository not on this list will be ignored.
        This is useful if you want to install just a single package or set of packages
        from a repository while including all other packages the repository provides.
        """
        return self._included_packages

    @included_packages.setter
    def included_packages(self, included_packages: List[Str]):
        self._included_packages = included_packages


class PackagesConfigurationData(DBusData):
    """Structure for the configuration of packages."""

    def __init__(self):
        self._core_group_enabled = True
        self._default_environment_enabled = False
        self._environment = ""
        self._groups = []
        self._groups_package_types = {}
        self._excluded_groups = []
        self._packages = []
        self._excluded_packages = []
        self._docs_excluded = False
        self._weakdeps_excluded = False
        self._missing_ignored = False
        self._broken_ignored = False
        self._languages = RPM_LANGUAGES_ALL
        self._multilib_policy = MULTILIB_POLICY_BEST
        self._timeout = DNF_DEFAULT_TIMEOUT
        self._retries = DNF_DEFAULT_RETRIES

    @property
    def core_group_enabled(self) -> Bool:
        """Should the core group be installed?

        :return: True if the core group should be installed
        :rtype: bool
        """
        return self._core_group_enabled

    @core_group_enabled.setter
    def core_group_enabled(self, value: Bool):
        self._core_group_enabled = value

    @property
    def default_environment_enabled(self) -> Bool:
        """Should a default environment be installed?

        :return: True if the default package set should be installed
        :rtype: bool
        """
        return self._default_environment_enabled

    @default_environment_enabled.setter
    def default_environment_enabled(self, value: Bool):
        self._default_environment_enabled = value

    @property
    def environment(self) -> Str:
        """The environment marked for installation.

        Examples of environments:

            Fedora Server Edition
            workstation-product-environment

        :return: a full environment name (as given in the comps.xml file)
        :rtype: str
        """
        return self._environment

    @environment.setter
    def environment(self, value: Str):
        self._environment = value

    @property
    def groups(self) -> List[Str]:
        """A list of groups and modules marked for installation.

        Examples of groups:

            Administration Tools
            3d-printing

        Examples of modules:

            django:1.6
            postgresql:9.6/server

        :return: a list of groups and modules
        :rtype: [str]
        """
        return self._groups

    @groups.setter
    def groups(self, value: List[Str]):
        self._groups = value

    @property
    def groups_package_types(self) -> Dict[Str, List[Str]]:
        """Types of packages in the groups that should be installed.

        Supported package types:

            mandatory
            default
            conditional
            optional

        :return: a dictionary that maps groups to package types
        :rtype: {str: [str]}
        """
        return self._groups_package_types

    @groups_package_types.setter
    def groups_package_types(self, value: Dict[Str, List[Str]]):
        self._groups_package_types = value

    @property
    def excluded_groups(self) -> List[Str]:
        """A list of groups and modules excluded from the installation.

        :return: a list of excluded groups and modules
        :rtype: [str]
        """
        return self._excluded_groups

    @excluded_groups.setter
    def excluded_groups(self, value: List[Str]):
        self._excluded_groups = value

    @property
    def packages(self) -> List[Str]:
        """A list of packages marked for installation.

        Examples of packages:

            vim
            kde-i18n-*

        :return: a list of packages
        :rtype: [str]
        """
        return self._packages

    @packages.setter
    def packages(self, value: List[Str]):
        self._packages = value

    @property
    def excluded_packages(self) -> List[Str]:
        """A list of packages excluded from the installation.

        :return: a list of excluded packages
        :rtype: [str]
        """
        return self._excluded_packages

    @excluded_packages.setter
    def excluded_packages(self, value: List[Str]):
        self._excluded_packages = value

    @property
    def docs_excluded(self) -> Bool:
        """Should the documentation be excluded during the installation?

        :return: True if packages documentation shouldn't be installed
        :rtype: bool
        """
        return self._docs_excluded

    @docs_excluded.setter
    def docs_excluded(self, value: Bool):
        self._docs_excluded = value

    @property
    def weakdeps_excluded(self) -> Bool:
        """Should the packages weak dependencies be excluded from the installation?

        :return: True if the weak dependencies should be excluded
        :rtype: bool
        """
        return self._weakdeps_excluded

    @weakdeps_excluded.setter
    def weakdeps_excluded(self, value: Bool):
        self._weakdeps_excluded = value

    @property
    def missing_ignored(self) -> Bool:
        """Ignore packages that are missing from the repositories.

        :return: True if missing packages should be ignored
        :rtype: bool
        """
        return self._missing_ignored

    @missing_ignored.setter
    def missing_ignored(self, value: Bool):
        self._missing_ignored = value

    @property
    def broken_ignored(self) -> Bool:
        """Ignore packages that have conflicts with other packages.

        :return: True if broken packages should be ignored
        :rtype: bool
        """
        return self._broken_ignored

    @broken_ignored.setter
    def broken_ignored(self, value: Bool):
        self._broken_ignored = value

    @property
    def languages(self) -> Str:
        """Languages marked for installation.

        This option does not specify what package groups should
        be installed. Instead, it controls which translation files
        from individual packages should be installed by setting
        RPM macros.

        There are special values for this property supported:

            none  - Use 'nil' in the rpm macro.
            all   - Do not change the default settings.

        In case multiple languages are specified they are separated
        by ',' in the string returned.

        :return: 'none' or 'all' or a list of languages separated by ','
        :rtype: str
        """
        return self._languages

    @languages.setter
    def languages(self, value: Str):
        """Languages marked for installation."""
        self._languages = value

    @property
    def multilib_policy(self) -> Str:
        """The multilib policy.

        Supported values:

            all     Install all available packages with compatible
                    architectures.
            best    Prefer packages which best match the system’s
                    architecture.

        :return: 'all' or 'best'
        :rtype: str
        """
        return self._multilib_policy

    @multilib_policy.setter
    def multilib_policy(self, value: Str):
        self._multilib_policy = value

    @property
    def timeout(self) -> Int:
        """Timeout how long to try before failing during the package installation.

        :return: a number of seconds to wait (or -1 by default)
        :rtype: int
        """
        return self._timeout

    @timeout.setter
    def timeout(self, value):
        self._timeout = value

    @property
    def retries(self) -> Int:
        """How many times to try before failing during the package installation.

        :return: a number of how many times to try (or -1 by default)
        :rtype: int
        """
        return self._retries

    @retries.setter
    def retries(self, value: Int):
        self._retries = value
