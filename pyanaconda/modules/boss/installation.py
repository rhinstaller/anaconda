#
# Copyright (C) 2021 Red Hat, Inc.
#
# This copyrighted material is made available to anyone wishing to use,
# modify, copy, or redistribute it subject to the terms and conditions of
# the GNU General Public License v.2, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY expressed or implied, including the implied warranties of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.  You should have received a copy of the
# GNU General Public License along with this program; if not, write to the
# Free Software Foundation, Inc., 31 Milk Street #960789 Boston, MA
# 02196 USA.  Any Red Hat trademarks that are incorporated in the
# source code or documentation are not subject to the GNU General Public
# License and may only be used or replicated with the express permission of
# Red Hat, Inc.

import glob
import os.path
import shutil

from pykickstart.constants import (
    KS_SCRIPT_POST,
    KS_SCRIPT_PREINSTALL,
    SNAPSHOT_WHEN_POST_INSTALL,
)

from pyanaconda import flags, network
from pyanaconda.anaconda_loggers import get_module_logger
from pyanaconda.core import util
from pyanaconda.core.configuration.anaconda import conf
from pyanaconda.core.constants import (
    CATEGORY_BOOTLOADER,
    CATEGORY_ENVIRONMENT,
    CATEGORY_SOFTWARE,
    CATEGORY_STORAGE,
    CATEGORY_SYSTEM,
    PAYLOAD_LIVE_TYPES,
    PAYLOAD_TYPE_DNF,
)
from pyanaconda.core.i18n import _
from pyanaconda.core.path import (
    join_paths,
    make_directories,
    open_with_perm,
)
from pyanaconda.core.service import is_service_installed
from pyanaconda.core.util import execWithRedirect, restorecon
from pyanaconda.installation_tasks import DBusTask, Task, TaskQueue
from pyanaconda.kexec import setup_kexec
from pyanaconda.modules.boss.install_manager.installation_category_interface import (
    CategoryReportTaskInterface,
)
from pyanaconda.modules.common.constants.objects import (
    BOOTLOADER,
    CERTIFICATES,
    FIREWALL,
    SCRIPTS,
    SNAPSHOT,
)
from pyanaconda.modules.common.constants.services import (
    BOSS,
    LOCALIZATION,
    NETWORK,
    PAYLOADS,
    RUNTIME,
    SECURITY,
    SERVICES,
    STORAGE,
    SUBSCRIPTION,
    TIMEZONE,
    USERS,
)
from pyanaconda.modules.common.task import Task as InstallationTask
from pyanaconda.modules.common.task import sync_run_task
from pyanaconda.modules.common.util import is_module_available

log = get_module_logger(__name__)

TARGET_LOG_DIR = "/var/log/anaconda/"

def _writeKS_via_boss():
    boss_proxy = BOSS.get_proxy()
    ks_string = boss_proxy.GenerateKickstart()
    path = conf.target.system_root + "/root/anaconda-ks.cfg"

    with open_with_perm(path, "w", 0o600) as f:
        f.write("# Generated by Anaconda {}\n".format(util.get_anaconda_version_string()))
        f.write(ks_string)


class CopyLogsTask(InstallationTask):
    """Task to copy logs to target system."""
    def __init__(self, sysroot):
        """Create a new task.

        :param sysroot: a path to the root of installed system
        :type sysroot: str
        """
        super().__init__()
        self._sysroot = sysroot

    @property
    def name(self):
        return "Copy installation logs"

    def run(self):
        """Copy installation logs and other related files, and do necessary operations on them.

        - Copy logs of all kinds, incl. ks scripts, journal dump, and lorax pkg list
        - Copy input kickstart file
        - SELinux contexts are left as is (fixed by SetContextsTask)
        """
        self._copy_kickstart()
        self._copy_logs()

    def _copy_logs(self):
        """Copy installation logs to the target system"""
        if not conf.target.can_save_installation_logs:
            log.warning("Installation logs will not be saved to the installed system due to the "
                        "nosave option.")
            return

        log.info("Copying logs from the installation environment.")
        self._create_logs_directory()
        self._copy_tmp_logs()
        self._copy_lorax_packages()
        self._copy_pre_script_logs()
        self._copy_dnf_debugdata()
        self._copy_post_script_logs()
        self._dump_journal()

    def _create_logs_directory(self):
        """Create directory for Anaconda logs on the install target"""
        make_directories(join_paths(self._sysroot, TARGET_LOG_DIR))

    def _copy_tmp_logs(self):
        """Copy a number of log files from /tmp"""
        log_files_to_copy = [
            "anaconda.log",
            "syslog",
            "X.log",
            "program.log",
            "packaging.log",
            "storage.log",
            "ifcfg.log",
            "lvm.log",
            "dnf.librepo.log",
            "hawkey.log",
            "dbus.log",
        ]
        for logfile in log_files_to_copy:
            self._copy_file_to_sysroot(
                join_paths("/tmp/", logfile),
                join_paths(TARGET_LOG_DIR, logfile)
            )

    def _copy_lorax_packages(self):
        """Copy list of packages used for creating the installation media"""
        self._copy_file_to_sysroot(
            "/root/lorax-packages.log",
            join_paths(TARGET_LOG_DIR, "lorax-packages.log")
        )

    def _copy_pre_script_logs(self):
        """Copy logs from %pre scripts"""
        self._copy_tree_to_sysroot(
            "/tmp/pre-anaconda-logs",
            TARGET_LOG_DIR
        )

    def _copy_dnf_debugdata(self):
        """Copy DNF debug data"""
        self._copy_tree_to_sysroot(
            "/root/debugdata",
            join_paths(TARGET_LOG_DIR, "dnf_debugdata/")
        )

    def _copy_post_script_logs(self):
        """Copy logs from %post scripts"""
        for logfile in glob.glob("/tmp/ks-script*.log"):
            self._copy_file_to_sysroot(
                logfile,
                join_paths(TARGET_LOG_DIR, os.path.basename(logfile))
            )

    def _dump_journal(self):
        """Dump journal from the installation environment"""
        tempfile = "/tmp/journal.log"
        with open_with_perm(tempfile, "w", perm=0o600) as logfile:
            execWithRedirect("journalctl", ["-b"], stdout=logfile, log_output=False)
        self._copy_file_to_sysroot(tempfile, join_paths(TARGET_LOG_DIR, "journal.log"))

    def _copy_kickstart(self):
        """Copy input kickstart file"""
        if conf.target.can_copy_input_kickstart:
            log.info("Copying input kickstart file.")
            self._copy_file_to_sysroot(
                "/run/install/ks.cfg",
                "/root/original-ks.cfg"
            )
        else:
            log.warning("Input kickstart will not be saved to the installed system due to the "
                        "nosave option.")

    def _copy_file_to_sysroot(self, src, dest):
        """Copy a file, if it exists, and set its access bits.

        :param str src: path to source file
        :param str dest: path to destination file within sysroot
        """
        if os.path.exists(src):
            log.info("Copying file: %s -> %s", src, dest)
            full_dest_path = join_paths(self._sysroot, dest)
            shutil.copyfile(
                src,
                full_dest_path
            )
            os.chmod(full_dest_path, 0o0600)

    def _copy_tree_to_sysroot(self, src, dest):
        """Copy a directory tree, if it exists, and set its access bits.

        :param str src: path to source directory
        :param str dest: path to destination directory within sysroot
        """
        if os.path.exists(src):
            log.info("Copying directory tree: %s -> %s", src, dest)
            full_dest_path = join_paths(self._sysroot, dest)
            shutil.copytree(
                src,
                full_dest_path,
                dirs_exist_ok=True
            )
            os.chmod(full_dest_path, 0o0600)


class SetContextsTask(InstallationTask):
    """Task to set file contexts on target system.

    We need to handle SELinux relabeling for a few reasons:

    - %post scripts that write files into places in /etc, but don't do labeling correctly
    - Anaconda code that does the same (e.g. moving our log files into /var/log/anaconda)
    - ostree payloads, where all of the labeling of /var is the installer's responsibility
      (see https://github.com/ostreedev/ostree/pull/872 )
    - OSTree variants of the traditional mounts if present
    """
    def __init__(self, sysroot):
        """Create a new task.

        :param sysroot: a path to the root of installed system
        :type sysroot: str
        """
        super().__init__()
        self._sysroot = sysroot

    @property
    def name(self):
        return "Set file contexts"

    def run(self):
        """Relabel files (set contexts).

        Do not fail if the executable is not present.
        """
        dirs_to_relabel = [
            "/boot",
            "/dev",
            "/etc",
            "/lib64",
            "/root",
            "/usr/lib",
            "/usr/lib64",
            "/var/cache/yum",
            "/var/home",
            "/var/lib",
            "/var/lock",
            "/var/log",
            "/var/media",
            "/var/mnt",
            "/var/opt",
            "/var/roothome",
            "/var/run",
            "/var/spool",
            "/var/srv"
        ]

        log.info("Restoring SELinux contexts.")
        if not restorecon(dirs_to_relabel, root=self._sysroot, skip_nonexistent=True):
            log.warning("Cannot restore contexts because restorecon was not installed.")


class RunInstallationTask(InstallationTask):
    """Task to run the installation queue."""

    def __init__(self, install_manager):
        """Create a new task.
        """
        super().__init__()
        self._total_steps = 0
        self._install_manager = install_manager

    @property
    def name(self):
        """Name of the task"""
        return "Run the installation queue."

    @property
    def steps(self):
        """Total number of steps."""
        return self._total_steps

    def run(self):
        """Run the task."""
        self._run_installation()

    def for_publication(self):
        """Return a DBus representation."""
        return CategoryReportTaskInterface(self)

    def _queue_started_cb(self, task):
        """The installation queue was started."""
        self.report_category(task.task_category)
        self.report_progress(task.status_message)

    def _task_completed_cb(self, task):
        """The installation task was completed."""
        self.report_progress("", step_size=1)

    def _progress_report_cb(self, step, message):
        """Handle a progress report of a task."""
        self.report_progress(message)

    def _prepare_configuration(self):
        """Prepare queue with tasks configuring installed system."""
        payloads_proxy = PAYLOADS.get_proxy()
        payload_path = payloads_proxy.ActivePayload
        if not payload_path:
            log.error("No active payload found! Can't continue install.")
            raise RuntimeError("No active payload")

        payload_proxy = PAYLOADS.get_proxy(payload_path)
        configuration_queue = TaskQueue("Configuration queue")

        # connect progress reporting
        configuration_queue.queue_started.connect(self._queue_started_cb)
        configuration_queue.task_completed.connect(self._task_completed_cb)

        # import certificates first
        # they may be required for subscription, initramfs regenerating, ... ?
        if is_module_available(SECURITY):
            certificates_import = TaskQueue(
                "Certificates import",
                _("Importing certificates"),
                CATEGORY_SYSTEM
            )
            certificates_proxy = SECURITY.get_proxy(CERTIFICATES)
            certificates_import.append_dbus_tasks(SECURITY, [
                certificates_proxy.InstallWithTask()
            ])
            configuration_queue.append(certificates_import)

        # add installation tasks for the Subscription DBus module
        if is_module_available(SUBSCRIPTION):
            # we only run the tasks if the Subscription module is available
            subscription_config = TaskQueue(
                "Subscription configuration",
                _("Configuring Red Hat subscription"),
                CATEGORY_SYSTEM
            )
            subscription_proxy = SUBSCRIPTION.get_proxy()
            subscription_dbus_tasks = subscription_proxy.InstallWithTasks()
            subscription_config.append_dbus_tasks(SUBSCRIPTION, subscription_dbus_tasks)
            configuration_queue.append(subscription_config)

        # schedule the execute methods of ksdata that require an installed system to be present
        os_config = TaskQueue(
            "Installed system configuration",
            _("Configuring installed system"),
            CATEGORY_SYSTEM
        )

        # add installation tasks for the Security DBus module
        if is_module_available(SECURITY):
            security_proxy = SECURITY.get_proxy()
            security_dbus_tasks = security_proxy.InstallWithTasks()
            os_config.append_dbus_tasks(SECURITY, security_dbus_tasks)

        # add installation tasks for the Timezone DBus module
        # run these tasks before tasks of the Services module
        if is_module_available(TIMEZONE):
            timezone_proxy = TIMEZONE.get_proxy()
            timezone_dbus_tasks = timezone_proxy.InstallWithTasks()
            os_config.append_dbus_tasks(TIMEZONE, timezone_dbus_tasks)

        # add installation tasks for the Services DBus module
        if is_module_available(SERVICES):
            services_proxy = SERVICES.get_proxy()
            services_dbus_tasks = services_proxy.InstallWithTasks()
            os_config.append_dbus_tasks(SERVICES, services_dbus_tasks)

        # add installation tasks for the Localization DBus module
        if is_module_available(LOCALIZATION):
            localization_proxy = LOCALIZATION.get_proxy()
            localization_dbus_tasks = localization_proxy.InstallWithTasks()
            os_config.append_dbus_tasks(LOCALIZATION, localization_dbus_tasks)

        # add the Firewall configuration task
        if conf.target.can_configure_network:
            firewall_proxy = NETWORK.get_proxy(FIREWALL)
            firewall_dbus_task = firewall_proxy.InstallWithTask()
            os_config.append_dbus_tasks(NETWORK, [firewall_dbus_task])

        configuration_queue.append(os_config)

        # schedule network configuration (if required)
        if conf.target.can_configure_network and conf.system.provides_network_config:
            overwrite = payload_proxy.Type in PAYLOAD_LIVE_TYPES
            network_config = TaskQueue(
                "Network configuration",
                _("Writing network configuration"),
                CATEGORY_SYSTEM
            )
            network_config.append(Task(
                "Network configuration",
                network.write_configuration,
                (overwrite, )
            ))
            configuration_queue.append(network_config)

        # add installation tasks for the Users DBus module
        if is_module_available(USERS):
            user_config = TaskQueue(
                "User creation",
                _("Creating users"),
                CATEGORY_SYSTEM
            )
            users_proxy = USERS.get_proxy()
            users_dbus_tasks = users_proxy.InstallWithTasks()
            user_config.append_dbus_tasks(USERS, users_dbus_tasks)
            configuration_queue.append(user_config)

        # Anaconda addon configuration
        addon_config = TaskQueue(
            "Anaconda addon configuration",
            _("Configuring addons"),
            CATEGORY_SYSTEM
        )

        tasks_list = self._install_manager.collect_install_system_tasks()
        for task_proxy in tasks_list:
            addon_config.append(DBusTask(task_proxy))

        configuration_queue.append(addon_config)

        # Initramfs generation
        generate_initramfs = TaskQueue(
            "Initramfs generation",
            _("Generating initramfs"),
            CATEGORY_BOOTLOADER
        )
        bootloader_proxy = STORAGE.get_proxy(BOOTLOADER)

        def run_generate_initramfs():
            tasks = bootloader_proxy.GenerateInitramfsWithTasks(
                payload_proxy.Type,
                payloads_proxy.GetKernelVersionList()
            )

            for task in tasks:
                sync_run_task(STORAGE.get_proxy(task))

        generate_initramfs.append(Task(
            "Generate initramfs",
            run_generate_initramfs
        ))
        configuration_queue.append(generate_initramfs)

        if is_module_available(SECURITY):
            security_proxy = SECURITY.get_proxy()

            # Configure FIPS.
            configuration_queue.append_dbus_tasks(SECURITY, [
                security_proxy.ConfigureFIPSWithTask()
            ])

            # Join a realm. This can run only after network
            # is configured in the target system chroot.
            configuration_queue.append_dbus_tasks(SECURITY, [
                security_proxy.JoinRealmWithTask()
            ])

        # Calling zipl should be the last task on s390
        configuration_queue.append_dbus_tasks(STORAGE, [
            bootloader_proxy.FixZIPLBootloaderWithTask()
        ])

        # setup kexec reboot if requested
        if flags.flags.kexec:
            kexec_setup = TaskQueue(
                "Kexec setup",
                _("Setting up kexec"),
                CATEGORY_BOOTLOADER
            )
            kexec_setup.append(Task(
                "Setup kexec",
                setup_kexec
            ))
            configuration_queue.append(kexec_setup)

        # write anaconda related configs & kickstarts
        write_configs = TaskQueue(
            "Write configs and kickstarts",
            _("Storing configuration files and kickstarts"),
            CATEGORY_SYSTEM
        )

        # Write the kickstart file to the installed system (or, copy the input
        # kickstart file over if one exists).
        if conf.target.can_save_output_kickstart:
            # write anaconda related configs & kickstarts
            write_configs.append(Task("Store kickstarts", _writeKS_via_boss))
        else:
            # don't write the kickstart file to the installed system if this has
            # been disabled by the nosave option
            log.warning("Writing of the output kickstart to installed system has been disabled"
                        " by the nosave option.")

        # only add write_configs to the main queue if we actually store some kickstarts/configs
        if write_configs.task_count:
            configuration_queue.append(write_configs)

        post_scripts = TaskQueue(
            "Post installation scripts",
            _("Running post-installation scripts"),
            CATEGORY_SYSTEM
        )
        scripts_proxy = RUNTIME.get_proxy(SCRIPTS)
        post_scripts.append_dbus_tasks(RUNTIME, [
            scripts_proxy.RunScriptsWithTask(KS_SCRIPT_POST)
        ])
        configuration_queue.append(post_scripts)

        configuration_queue.append(Task(
            "Copy installation logs",
            CopyLogsTask(conf.target.system_root).run
        ))
        configuration_queue.append(Task(
            "Set file contexts",
            SetContextsTask(conf.target.system_root).run
        ))

        return configuration_queue

    def _prepare_installation(self):
        """Prepare the installation task queue.

        This method builds and returns a queue of tasks that perform the system installation.
        The queue includes tasks for setting up the environment, configuring storage,
        installing the software payload, running installation scripts, setting up the
        bootloader, and executing post-installation steps.
        """
        payloads_proxy = PAYLOADS.get_proxy()
        payload_path = payloads_proxy.ActivePayload
        if not payload_path:
            log.error("No active payload found! Can't continue install.")
            raise RuntimeError("No active payload")

        payload_proxy = PAYLOADS.get_proxy(payload_path)
        installation_queue = TaskQueue("Installation queue")

        # connect progress reporting
        installation_queue.queue_started.connect(self._queue_started_cb)
        installation_queue.task_completed.connect(self._task_completed_cb)

        # setup the installation environment
        setup_environment = TaskQueue(
            "Installation environment setup",
            _("Setting up the installation environment"),
            CATEGORY_ENVIRONMENT
        )

        tasks_list = self._install_manager.collect_configure_runtime_tasks()
        for task_proxy in tasks_list:
            setup_environment.append(DBusTask(task_proxy))

        # Add configuration tasks for the Localization DBus module.
        if is_module_available(LOCALIZATION):
            localization_proxy = LOCALIZATION.get_proxy()
            # Populate the missing keyboard values before the payload installation,
            # so the module requirements can be generated for the right configuration.
            # FIXME: Make sure that the module always returns right values.
            populate_task = localization_proxy.PopulateMissingKeyboardConfigurationWithTask()
            setup_environment.append_dbus_tasks(LOCALIZATION, [populate_task])

        installation_queue.append(setup_environment)

        # Do partitioning.
        # Depending on current payload the storage might be apparently configured
        # either before or after package/payload installation.
        # So let's have two task queues - early storage & late storage.
        storage_proxy = STORAGE.get_proxy()
        early_storage = TaskQueue(
            "Early storage configuration",
            _("Configuring storage"),
            CATEGORY_STORAGE
        )
        early_storage.append_dbus_tasks(STORAGE, storage_proxy.InstallWithTasks())

        if payload_proxy.Type == PAYLOAD_TYPE_DNF:
            conf_task = storage_proxy.WriteConfigurationWithTask()
            early_storage.append_dbus_tasks(STORAGE, [conf_task])

        installation_queue.append(early_storage)

        # Run %pre-install scripts with the filesystem mounted and no packages
        pre_install_scripts = TaskQueue(
            "Pre-install scripts",
            _("Running pre-installation scripts"),
            CATEGORY_ENVIRONMENT
        )
        scripts_proxy = RUNTIME.get_proxy(SCRIPTS)
        pre_install_scripts.append_dbus_tasks(RUNTIME, [
            scripts_proxy.RunScriptsWithTask(KS_SCRIPT_PREINSTALL)
        ])
        installation_queue.append(pre_install_scripts)

        # Do various pre-installation tasks
        # - try to discover a realm (if any)
        # - check for possibly needed additional packages.
        pre_install = TaskQueue(
            "Pre install tasks",
            _("Running pre-installation tasks"),
            CATEGORY_SOFTWARE
        )

        # Make name resolution work for rpm scripts in chroot.
        # Also make sure dns resolution works in %post scripts
        # when systemd-resolved is not available.
        if conf.system.provides_resolver_config and \
                not is_service_installed("systemd-resolved.service"):
            pre_install.append(Task(
                "Copy resolv.conf to sysroot",
                network.copy_resolv_conf_to_root,
                (conf.target.system_root, )
            ))

        if is_module_available(SECURITY):
            security_proxy = SECURITY.get_proxy()

            # Discover a realm.
            pre_install.append_dbus_tasks(SECURITY, [
                security_proxy.DiscoverRealmWithTask()
            ])

            # Set up FIPS for the payload installation.
            fips_task = security_proxy.PreconfigureFIPSWithTask(payload_proxy.Type)
            pre_install.append_dbus_tasks(SECURITY, [fips_task])

            # Import certificates so they are available for rpm scripts
            certificates_proxy = SECURITY.get_proxy(CERTIFICATES)
            certificates_task = certificates_proxy.PreInstallWithTask(payload_proxy.Type)
            pre_install.append_dbus_tasks(SECURITY, [certificates_task])

        installation_queue.append(pre_install)

        payload_install = TaskQueue(
            "Payload installation",
            _("Installing the software"),
            CATEGORY_SOFTWARE
        )

        tasks = payloads_proxy.InstallWithTasks()
        payload_install.append_dbus_tasks(PAYLOADS, tasks)

        installation_queue.append(payload_install)

        # for some payloads storage is configured after the payload is installed
        if payload_proxy.Type != PAYLOAD_TYPE_DNF:
            late_storage = TaskQueue(
                "Late storage configuration",
                _("Configuring storage"),
                CATEGORY_STORAGE,
            )
            conf_task = storage_proxy.WriteConfigurationWithTask()
            late_storage.append_dbus_tasks(STORAGE, [conf_task])
            installation_queue.append(late_storage)

        # Do bootloader.
        bootloader_proxy = STORAGE.get_proxy(BOOTLOADER)
        bootloader_install = TaskQueue(
            "Bootloader installation",
            _("Installing boot loader"),
            CATEGORY_BOOTLOADER
        )

        def run_configure_bootloader():
            task_proxies = self._install_manager.collect_configure_bootloader_tasks(payloads_proxy.GetKernelVersionList())

            for proxy in task_proxies:
                sync_run_task(proxy)

        bootloader_install.append(Task(
            "Configure bootloader",
            run_configure_bootloader
        ))

        def run_install_bootloader():
            tasks = bootloader_proxy.InstallBootloaderWithTasks(
                payload_proxy.Type,
                payloads_proxy.GetKernelVersionList()
            )

            for task in tasks:
                sync_run_task(STORAGE.get_proxy(task))

        bootloader_install.append(Task(
            "Install bootloader",
            run_install_bootloader
        ))
        installation_queue.append(bootloader_install)

        post_install = TaskQueue(
            "Post-installation setup tasks",
            _("Performing post-installation setup tasks"),
            CATEGORY_SYSTEM
        )
        tasks = payloads_proxy.PostInstallWithTasks()
        post_install.append_dbus_tasks(PAYLOADS, tasks)
        installation_queue.append(post_install)

        # Create snapshot
        snapshot_proxy = STORAGE.get_proxy(SNAPSHOT)

        if snapshot_proxy.IsRequested(SNAPSHOT_WHEN_POST_INSTALL):
            snapshot_creation = TaskQueue(
                "Creating post installation snapshots",
                _("Creating snapshots"),
                CATEGORY_STORAGE
            )
            snapshot_task = snapshot_proxy.CreateWithTask(SNAPSHOT_WHEN_POST_INSTALL)
            snapshot_creation.append_dbus_tasks(STORAGE, [snapshot_task])
            installation_queue.append(snapshot_creation)

        return installation_queue

    def _run_installation(self):
        """Run the complete installation."""
        queue = TaskQueue("Complete installation queue")
        queue.append(self._prepare_installation())
        queue.append(self._prepare_configuration())

        # notify progress tracking about the number of steps
        self._total_steps = queue.task_count

        # Set the progress reporting callback of the DBus tasks.
        # FIXME: This is a temporary workaround.
        for item in queue.nested_items:
            if isinstance(item, DBusTask):
                item._progress_cb = self._progress_report_cb

        # log contents of the main task queue
        log.info(queue.summary)

        # log tasks and queues when they are started
        # - note that we are using generators to add the counter
        queue_counter = util.item_counter(queue.queue_count)
        task_started_counter = util.item_counter(queue.task_count)
        task_completed_counter = util.item_counter(queue.task_count)
        queue.queue_started.connect(
            lambda x: log.info("Queue started: %s (%s)", x.name, next(queue_counter))
        )
        queue.task_started.connect(
            lambda x: log.info("Task started: %s (%s)", x.name, next(task_started_counter))
        )
        queue.task_completed.connect(
            lambda x: log.debug("Task completed: %s (%s) (%1.1f s)", x.name,
                                next(task_completed_counter), x.elapsed_time)
        )

        # start the task queue
        queue.start()

        # done
        self.report_progress(_("Complete!"), step_number=self.steps)

        # this message is automatically detected by QE tools, do not change it lightly
        log.info(
            "All tasks in the installation queue are done. "
            "Installation successfully finished."
        )
